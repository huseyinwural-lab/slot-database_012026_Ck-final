.......F.........FFF.FF..s....F...FF..............FFFFF.FF..FFFFFFF..... [ 54%]
..FFFFFF...............FF..F...................FFFF......FFF             [100%]
=================================== FAILURES ===================================
_______________________ test_callback_security_negative ________________________

    @pytest.mark.asyncio
    async def test_callback_security_negative():
        async with AsyncClient(base_url=BASE_URL) as client:
    
            payload = {
                "provider_id": "mock-provider",
                "event_type": "BET",
                "session_id": "fake-session",
                "provider_round_id": "rnd-1",
                "provider_event_id": "evt-1",
                "amount": 10.0,
                "currency": "USD"
            }
    
            # Case 1: Missing Headers
            resp = await client.post(CALLBACK_URL, json=payload)
>           assert resp.status_code == 401
E           assert 422 == 401
E            +  where 422 = <Response [422 Unprocessable Entity]>.status_code

tests/test_callback_security.py:35: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:10,963 - httpx - INFO - HTTP Request: POST http://localhost:8001/api/v1/integrations/callback "HTTP/1.1 422 Unprocessable Entity"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1740 HTTP Request: POST http://localhost:8001/api/v1/integrations/callback "HTTP/1.1 422 Unprocessable Entity"
_________________________________ test_engine __________________________________
async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted
___________________________ test_webhook_idempotency ___________________________

client = <httpx.AsyncClient object at 0xf92054573050>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    def test_webhook_idempotency(client, async_session_factory):
        async def _seed():
            async with async_session_factory() as session:
                tenant = await _create_tenant(session)
                player = await _create_player(session, tenant.id, kyc_status="verified", balance_available=0)
                return tenant, player
    
        tenant, player = asyncio.run(_seed())
    
        payload = {
            "provider_event_id": "evt-123",
            "player_id": player.id,
            "tenant_id": tenant.id,
            "amount": 50,
            "currency": "USD",
            "type": "deposit",
        }
    
        # First call -> creates transaction and FIN_WEBHOOK_RECEIVED
        r1 = client.post("/api/v1/payments/webhook/mock", json=payload)
>       assert r1.status_code == 200
               ^^^^^^^^^^^^^^
E       AttributeError: 'coroutine' object has no attribute 'status_code'

tests/test_finance_webhook_idempotency.py:36: AttributeError
___________ test_approve_requested_withdraw_does_not_change_balance ____________

client = <httpx.AsyncClient object at 0xf920545453d0>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    @pytest.mark.asyncio
    async def test_approve_requested_withdraw_does_not_change_balance(client, async_session_factory):
        tenant, player, admin, player_token, admin_token = await _seed_admin_and_player(async_session_factory)
    
        # Player makes a withdrawal request
        headers_player = {"Authorization": f"Bearer {player_token}", "Idempotency-Key": "wd-admin-1"}
        r_wd = await client.post(
            "/api/v1/player/wallet/withdraw",
            json={"amount": 30, "method": "bank", "address": "addr"},
            headers=headers_player,
        )
        assert r_wd.status_code in (200, 201)
    
        body = r_wd.json()
        tx_id = body["transaction"]["id"]
    
        # Snapshot balances before admin action
        async def _load_before():
            async with async_session_factory() as session:
                db_player = await session.get(Player, player.id)
                return db_player.balance_real_available, db_player.balance_real_held
    
        before_available, before_held = await _load_before()
    
        # Admin approves
        headers_admin = {"Authorization": f"Bearer {admin_token}"}
        r_app = await client.post(
            f"/api/v1/finance/withdrawals/{tx_id}/review",
            json={"action": "approve"},
            headers=headers_admin,
        )
>       assert r_app.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests/test_finance_withdraw_admin_api.py:106: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:11,727 - app.request - INFO - request
2025-12-26 19:03:11,727 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 200 OK"
2025-12-26 19:03:11,732 - app.request - INFO - request
2025-12-26 19:03:11,732 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/finance/withdrawals/cf6fd32d-b0e9-418e-aced-8124879bb532/review "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call -------------------------------
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 200 OK"
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/finance/withdrawals/cf6fd32d-b0e9-418e-aced-8124879bb532/review "HTTP/1.1 400 Bad Request"
__________________ test_mark_paid_from_approved_reduces_held ___________________

client = <httpx.AsyncClient object at 0xf92054542e50>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    @pytest.mark.asyncio
    async def test_mark_paid_from_approved_reduces_held(client, async_session_factory):
        tenant, player, admin, player_token, admin_token = await _seed_admin_and_player(async_session_factory)
    
        headers_player = {"Authorization": f"Bearer {player_token}", "Idempotency-Key": "wd-admin-3"}
        r_wd = await client.post(
            "/api/v1/player/wallet/withdraw",
            json={"amount": 25, "method": "bank", "address": "addr"},
            headers=headers_player,
        )
        assert r_wd.status_code in (200, 201)
        tx_id = r_wd.json()["transaction"]["id"]
    
        headers_admin = {"Authorization": f"Bearer {admin_token}"}
        r_app = await client.post(
            f"/api/v1/finance/withdrawals/{tx_id}/review",
            json={"action": "approve"},
            headers=headers_admin,
        )
>       assert r_app.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests/test_finance_withdraw_admin_api.py:184: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:11,814 - app.request - INFO - request
2025-12-26 19:03:11,815 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 200 OK"
2025-12-26 19:03:11,818 - app.request - INFO - request
2025-12-26 19:03:11,818 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/finance/withdrawals/46fd9041-28a6-4f7c-b529-a161e23cda5f/review "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call -------------------------------
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 200 OK"
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/finance/withdrawals/46fd9041-28a6-4f7c-b529-a161e23cda5f/review "HTTP/1.1 400 Bad Request"
__________________ test_invalid_state_transitions_return_409 ___________________

client = <httpx.AsyncClient object at 0xf9205462c710>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    @pytest.mark.asyncio
    async def test_invalid_state_transitions_return_409(client, async_session_factory):
        tenant, player, admin, player_token, admin_token = await _seed_admin_and_player(async_session_factory)
    
        headers_player = {"Authorization": f"Bearer {player_token}", "Idempotency-Key": "wd-admin-4"}
        r_wd = await client.post(
            "/api/v1/player/wallet/withdraw",
            json={"amount": 10, "method": "bank", "address": "addr"},
            headers=headers_player,
        )
        assert r_wd.status_code in (200, 201)
        tx_id = r_wd.json()["transaction"]["id"]
    
        # Try mark-paid directly from requested -> should be 409
        headers_admin = {"Authorization": f"Bearer {admin_token}"}
        r_paid = await client.post(
            f"/api/v1/finance/withdrawals/{tx_id}/mark-paid",
            headers=headers_admin,
        )
>       assert r_paid.status_code == 409
E       assert 422 == 409
E        +  where 422 = <Response [422 Unprocessable Entity]>.status_code

tests/test_finance_withdraw_admin_api.py:232: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:11,907 - app.request - INFO - request
2025-12-26 19:03:11,908 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 200 OK"
2025-12-26 19:03:11,911 - app.request - INFO - request
2025-12-26 19:03:11,912 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/finance/withdrawals/13282b41-3f37-424f-ba64-aefc7d09ced4/mark-paid "HTTP/1.1 422 Unprocessable Entity"
------------------------------ Captured log call -------------------------------
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 200 OK"
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/finance/withdrawals/13282b41-3f37-424f-ba64-aefc7d09ced4/mark-paid "HTTP/1.1 422 Unprocessable Entity"
_____________________ test_append_event_idempotency_client _____________________

async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    def test_append_event_idempotency_client(async_session_factory):
        async def _run():
            async with async_session_factory() as session:
                tenant = await _create_tenant(session)
                player = await _create_player(session, tenant.id)
    
                e1, created1 = await append_event(
                    session,
                    tenant_id=tenant.id,
                    player_id=player.id,
                    tx_id="tx-1",
                    type="deposit",
                    direction="credit",
                    amount=10,
                    currency="USD",
                    status="deposit_captured",
                    idempotency_key="idem-1",
                )
    
                e2, created2 = await append_event(
                    session,
                    tenant_id=tenant.id,
                    player_id=player.id,
                    tx_id="tx-1",
                    type="deposit",
                    direction="credit",
                    amount=10,
                    currency="USD",
                    status="deposit_captured",
                    idempotency_key="idem-1",
                )
    
                assert e1.id == e2.id
    
                stmt = select(LedgerTransaction).where(LedgerTransaction.tenant_id == tenant.id)
                rows = (await session.execute(stmt)).scalars().all()
                assert len(rows) == 1
    
>       asyncio.run(_run())

tests/test_ledger_repo.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/asyncio/runners.py:190: in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/asyncio/base_events.py:654: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def _run():
        async with async_session_factory() as session:
            tenant = await _create_tenant(session)
            player = await _create_player(session, tenant.id)
    
            e1, created1 = await append_event(
                session,
                tenant_id=tenant.id,
                player_id=player.id,
                tx_id="tx-1",
                type="deposit",
                direction="credit",
                amount=10,
                currency="USD",
                status="deposit_captured",
                idempotency_key="idem-1",
            )
    
            e2, created2 = await append_event(
                session,
                tenant_id=tenant.id,
                player_id=player.id,
                tx_id="tx-1",
                type="deposit",
                direction="credit",
                amount=10,
                currency="USD",
                status="deposit_captured",
                idempotency_key="idem-1",
            )
    
            assert e1.id == e2.id
    
            stmt = select(LedgerTransaction).where(LedgerTransaction.tenant_id == tenant.id)
            rows = (await session.execute(stmt)).scalars().all()
>           assert len(rows) == 1
E           AssertionError: assert 12 == 1
E            +  where 12 = len([LedgerTransaction(type='wallet', amount=50.0, status='deposit_succeeded', provider='mockpsp', provider_event_id='capt..., idempotency_key='wd-admin-4', provider_ref=None, created_at=datetime.datetime(2025, 12, 26, 19, 3, 11, 898701)), ...])

tests/test_ledger_repo.py:58: AssertionError
__________ test_withdraw_requested_creates_hold_in_player_and_ledger ___________

client = <httpx.AsyncClient object at 0xf920545fa710>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    def test_withdraw_requested_creates_hold_in_player_and_ledger(client, async_session_factory):
        settings.ledger_shadow_write = True
    
        async def _run():
            async with async_session_factory() as session:
                tenant = await _create_tenant(session)
                # Start with zero balance in DB; fund via deposit so ledger snapshot sees it
                player = await _create_player(session, tenant.id, balance_available=0.0, kyc_status="verified")
                token = _make_player_token(player.id, tenant.id)
    
            # Fund via deposit so both player and ledger start from 100 available
            dep_headers = {"Authorization": f"Bearer {token}", "Idempotency-Key": "idem-deposit-1"}
            r_dep = client.post(
                "/api/v1/player/wallet/deposit",
                json={"amount": 100.0, "method": "test"},
                headers=dep_headers,
            )
            assert r_dep.status_code in (200, 201)
    
            headers = {"Authorization": f"Bearer {token}", "Idempotency-Key": "idem-withdraw-1"}
            r = client.post(
                "/api/v1/player/wallet/withdraw",
                json={"amount": 10.0, "method": "test_bank", "address": "e2e"},
                headers=headers,
            )
            assert r.status_code in (200, 201)
    
            async with async_session_factory() as session:
                db_player = await session.get(Player, player.id)
                assert db_player.balance_real_available == pytest.approx(90.0)
                assert db_player.balance_real_held == pytest.approx(10.0)
    
                wb = (
                    await session.execute(
                        select(WalletBalance).where(
                            WalletBalance.tenant_id == tenant.id,
                            WalletBalance.player_id == player.id,
                            WalletBalance.currency == "USD",
                        )
                    )
                ).scalars().first()
                assert wb is not None
                assert wb.balance_real_available == pytest.approx(90.0)
                assert wb.balance_real_pending == pytest.approx(10.0)
    
                evs = (
                    await session.execute(
                        select(LedgerTransaction).where(
                            LedgerTransaction.player_id == player.id,
                            LedgerTransaction.status == "withdraw_requested",
                            LedgerTransaction.idempotency_key == "idem-withdraw-1",
                        )
                    )
                ).scalars().all()
                assert len(evs) == 1
    
>       asyncio.run(_run())

tests/test_ledger_shadow_flows.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/asyncio/runners.py:190: in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/asyncio/base_events.py:654: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def _run():
        async with async_session_factory() as session:
            tenant = await _create_tenant(session)
            # Start with zero balance in DB; fund via deposit so ledger snapshot sees it
            player = await _create_player(session, tenant.id, balance_available=0.0, kyc_status="verified")
            token = _make_player_token(player.id, tenant.id)
    
        # Fund via deposit so both player and ledger start from 100 available
        dep_headers = {"Authorization": f"Bearer {token}", "Idempotency-Key": "idem-deposit-1"}
        r_dep = client.post(
            "/api/v1/player/wallet/deposit",
            json={"amount": 100.0, "method": "test"},
            headers=dep_headers,
        )
>       assert r_dep.status_code in (200, 201)
               ^^^^^^^^^^^^^^^^^
E       AttributeError: 'coroutine' object has no attribute 'status_code'

tests/test_ledger_shadow_flows.py:35: AttributeError
_________ test_withdraw_idempotent_request_does_not_double_apply_hold __________

client = <httpx.AsyncClient object at 0xf920545eba90>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    def test_withdraw_idempotent_request_does_not_double_apply_hold(client, async_session_factory):
        settings.ledger_shadow_write = True
    
        async def _run():
            async with async_session_factory() as session:
                tenant = await _create_tenant(session)
                player = await _create_player(session, tenant.id, balance_available=0.0, kyc_status="verified")
                token = _make_player_token(player.id, tenant.id)
    
            # Fund via deposit so both player and ledger start from 100 available
            dep_headers = {"Authorization": f"Bearer {token}", "Idempotency-Key": "idem-deposit-2"}
            r_dep = client.post(
                "/api/v1/player/wallet/deposit",
                json={"amount": 100.0, "method": "test"},
                headers=dep_headers,
            )
            assert r_dep.status_code in (200, 201)
    
            headers = {"Authorization": f"Bearer {token}", "Idempotency-Key": "idem-withdraw-dup"}
            payload = {"amount": 10.0, "method": "test_bank", "address": "e2e"}
    
            r1 = client.post("/api/v1/player/wallet/withdraw", json=payload, headers=headers)
            assert r1.status_code in (200, 201)
            r2 = client.post("/api/v1/player/wallet/withdraw", json=payload, headers=headers)
            assert r2.status_code in (200, 201)
    
            async with async_session_factory() as session:
                wb = (
                    await session.execute(
                        select(WalletBalance).where(
                            WalletBalance.tenant_id == tenant.id,
                            WalletBalance.player_id == player.id,
                            WalletBalance.currency == "USD",
                        )
                    )
                ).scalars().first()
                assert wb.balance_real_available == pytest.approx(90.0)
                assert wb.balance_real_pending == pytest.approx(10.0)
    
                evs = (
                    await session.execute(
                        select(LedgerTransaction).where(
                            LedgerTransaction.player_id == player.id,
                            LedgerTransaction.status == "withdraw_requested",
                            LedgerTransaction.idempotency_key == "idem-withdraw-dup",
                        )
                    )
                ).scalars().all()
                assert len(evs) == 1
    
>       asyncio.run(_run())

tests/test_ledger_shadow_flows.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/asyncio/runners.py:190: in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/asyncio/base_events.py:654: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def _run():
        async with async_session_factory() as session:
            tenant = await _create_tenant(session)
            player = await _create_player(session, tenant.id, balance_available=0.0, kyc_status="verified")
            token = _make_player_token(player.id, tenant.id)
    
        # Fund via deposit so both player and ledger start from 100 available
        dep_headers = {"Authorization": f"Bearer {token}", "Idempotency-Key": "idem-deposit-2"}
        r_dep = client.post(
            "/api/v1/player/wallet/deposit",
            json={"amount": 100.0, "method": "test"},
            headers=dep_headers,
        )
>       assert r_dep.status_code in (200, 201)
               ^^^^^^^^^^^^^^^^^
E       AttributeError: 'coroutine' object has no attribute 'status_code'

tests/test_ledger_shadow_flows.py:94: AttributeError
_ test_payout_success_transitions_to_paid_and_writes_single_withdraw_paid_ledger _

client = <httpx.AsyncClient object at 0xf9205444b550>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    @pytest.mark.asyncio
    async def test_payout_success_transitions_to_paid_and_writes_single_withdraw_paid_ledger(
        client, async_session_factory
    ):
        tenant, player, admin, admin_token = await _seed_admin_player_and_balance(async_session_factory)
    
        # Player initiates withdrawal
        from tests.conftest import _make_player_token
    
        player_token = _make_player_token(player.id, tenant.id)
    
        headers_player = {"Authorization": f"Bearer {player_token}", "Idempotency-Key": "payout-success-wd"}
        r_wd = await client.post(
            "/api/v1/player/wallet/withdraw",
            json={"amount": 30, "method": "bank", "address": "addr"},
            headers=headers_player,
        )
>       assert r_wd.status_code in (200, 201)
E       assert 400 in (200, 201)
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests/test_payout_flow.py:105: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:12,435 - app.request - INFO - request
2025-12-26 19:03:12,436 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call -------------------------------
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
______ test_payout_fail_transitions_to_payout_failed_and_writes_no_ledger ______

client = <httpx.AsyncClient object at 0xf920545061d0>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    @pytest.mark.asyncio
    async def test_payout_fail_transitions_to_payout_failed_and_writes_no_ledger(
        client, async_session_factory
    ):
        tenant, player, admin, admin_token = await _seed_admin_player_and_balance(async_session_factory)
    
        from tests.conftest import _make_player_token
    
        player_token = _make_player_token(player.id, tenant.id)
    
        headers_player = {"Authorization": f"Bearer {player_token}", "Idempotency-Key": "payout-fail-wd"}
        r_wd = await client.post(
            "/api/v1/player/wallet/withdraw",
            json={"amount": 20, "method": "bank", "address": "addr"},
            headers=headers_player,
        )
>       assert r_wd.status_code in (200, 201)
E       assert 400 in (200, 201)
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests/test_payout_flow.py:170: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:12,458 - app.request - INFO - request
2025-12-26 19:03:12,459 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call -------------------------------
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
____ test_payout_replay_same_idempotency_key_no_duplicate_ledger_or_attempt ____

client = <httpx.AsyncClient object at 0xf920544a4410>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    @pytest.mark.asyncio
    async def test_payout_replay_same_idempotency_key_no_duplicate_ledger_or_attempt(
        client, async_session_factory
    ):
        tenant, player, admin, admin_token = await _seed_admin_player_and_balance(async_session_factory)
    
        from tests.conftest import _make_player_token
    
        player_token = _make_player_token(player.id, tenant.id)
    
        headers_player = {"Authorization": f"Bearer {player_token}", "Idempotency-Key": "payout-replay-wd"}
        r_wd = await client.post(
            "/api/v1/player/wallet/withdraw",
            json={"amount": 15, "method": "bank", "address": "addr"},
            headers=headers_player,
        )
>       assert r_wd.status_code in (200, 201)
E       assert 400 in (200, 201)
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests/test_payout_flow.py:233: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:12,478 - app.request - INFO - request
2025-12-26 19:03:12,479 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call -------------------------------
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
_____________ test_payout_webhook_replay_no_duplicate_paid_ledger ______________

client = <httpx.AsyncClient object at 0xf920543c7310>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    @pytest.mark.asyncio
    async def test_payout_webhook_replay_no_duplicate_paid_ledger(client, async_session_factory):
        """TCK-P05-105-T1: Webhook success replay does not duplicate ledger or attempt."""
    
        tenant, player, admin, admin_token = await _seed_admin_player_and_balance(async_session_factory)
    
        from tests.conftest import _make_player_token
    
        player_token = _make_player_token(player.id, tenant.id)
    
        # Player withdraws
        headers_player = {"Authorization": f"Bearer {player_token}", "Idempotency-Key": "payout-webhook-success-wd"}
        r_wd = await client.post(
            "/api/v1/player/wallet/withdraw",
            json={"amount": 30, "method": "bank", "address": "addr"},
            headers=headers_player,
        )
>       assert r_wd.status_code in (200, 201)
E       assert 400 in (200, 201)
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests/test_payout_flow.py:305: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:12,498 - app.request - INFO - request
2025-12-26 19:03:12,499 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call -------------------------------
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
____________ test_payout_webhook_replay_no_duplicate_effect_failed _____________

client = <httpx.AsyncClient object at 0xf9205452ad90>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    @pytest.mark.asyncio
    async def test_payout_webhook_replay_no_duplicate_effect_failed(client, async_session_factory):
        """TCK-P05-105-T2: Webhook failed replay has no ledger and no extra attempts."""
    
        tenant, player, admin, admin_token = await _seed_admin_player_and_balance(async_session_factory)
    
        from tests.conftest import _make_player_token
    
        player_token = _make_player_token(player.id, tenant.id)
    
        headers_player = {"Authorization": f"Bearer {player_token}", "Idempotency-Key": "payout-webhook-fail-wd"}
        r_wd = await client.post(
            "/api/v1/player/wallet/withdraw",
            json={"amount": 20, "method": "bank", "address": "addr"},
            headers=headers_player,
        )
>       assert r_wd.status_code in (200, 201)
E       assert 400 in (200, 201)
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests/test_payout_flow.py:396: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:12,519 - app.request - INFO - request
2025-12-26 19:03:12,520 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call -------------------------------
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
___________________ test_payout_provider_mock_gated_in_prod ____________________

client = <httpx.AsyncClient object at 0xf9205449f550>
admin_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkMjliNmM3OS01OWM2LTQ3MGQtYmNkZS01ODU2MmM3NzE4NzIiLCJlbWFpbCI6ImFkbWlu...ZTFhLTgzZDQtZGZjYzUyNmI1NjljIiwicm9sZSI6IkFkbWluIiwiZXhwIjoxNzY2ODYyMTkyfQ.hCY66nG8IeamxlMnawhuBOogp6KhSPrUvDOlFemz8dE'
session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xf9205449cd10>

    @pytest.mark.asyncio
    async def test_payout_provider_mock_gated_in_prod(client: AsyncClient, admin_token, session):
        """
        Ensure mock payouts are gated in production.
        """
        # 0. Get Tenant ID from Admin Token (or DB)
        from app.models.sql_models import Tenant
        stmt = select(Tenant)
        tenant = (await session.execute(stmt)).scalars().first()
        assert tenant is not None
        tenant_id = tenant.id
    
        # 1. Create a withdrawal
        tx = Transaction(
            tenant_id=tenant_id,
            player_id="player1",
            type="withdrawal",
            amount=50.0,
            currency="USD",
            status="pending",
            state="approved",
            provider="mock_psp"
        )
        session.add(tx)
        await session.commit()
        await session.refresh(tx)
    
        # 2. Attempt Retry in PROD
        with patch("config.settings.env", "prod"):
            with patch("config.settings.allow_test_payment_methods", False):
                resp = await client.post(
                    f"/api/v1/finance-actions/withdrawals/{tx.id}/retry",
                    json={"reason": "Retrying"},
                    headers={"Authorization": f"Bearer {admin_token}"}
                )
>               assert resp.status_code == 403
E               assert 404 == 403
E                +  where 404 = <Response [404 Not Found]>.status_code

tests/test_payout_provider.py:43: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:12,560 - app.request - INFO - request
2025-12-26 19:03:12,561 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/finance-actions/withdrawals/3db0376f-20c1-40c5-b800-8cc4c02b5c72/retry "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/finance-actions/withdrawals/3db0376f-20c1-40c5-b800-8cc4c02b5c72/retry "HTTP/1.1 404 Not Found"
___________________ test_payout_provider_mock_allowed_in_dev ___________________

client = <httpx.AsyncClient object at 0xf9205449ddd0>
admin_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkMjliNmM3OS01OWM2LTQ3MGQtYmNkZS01ODU2MmM3NzE4NzIiLCJlbWFpbCI6ImFkbWlu...ZTFhLTgzZDQtZGZjYzUyNmI1NjljIiwicm9sZSI6IkFkbWluIiwiZXhwIjoxNzY2ODYyMTkyfQ.hCY66nG8IeamxlMnawhuBOogp6KhSPrUvDOlFemz8dE'
session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xf9205448f490>

    @pytest.mark.asyncio
    async def test_payout_provider_mock_allowed_in_dev(client: AsyncClient, admin_token, session):
        """
        Ensure mock payouts work in dev.
        """
        # 0. Get Tenant ID
        from app.models.sql_models import Tenant
        stmt = select(Tenant)
        tenant = (await session.execute(stmt)).scalars().first()
        assert tenant is not None
        tenant_id = tenant.id
    
        tx = Transaction(
            tenant_id=tenant_id,
            player_id="player2",
            type="withdrawal",
            amount=50.0,
            currency="USD",
            status="pending",
            state="approved",
            provider="mock_psp"
        )
        session.add(tx)
        await session.commit()
        await session.refresh(tx)
    
        resp = await client.post(
            f"/api/v1/finance-actions/withdrawals/{tx.id}/retry",
            json={"reason": "Retrying"},
            headers={"Authorization": f"Bearer {admin_token}"}
        )
>       assert resp.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/test_payout_provider.py:77: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:12,578 - app.request - INFO - request
2025-12-26 19:03:12,578 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/finance-actions/withdrawals/b9e8e571-8724-4eb7-b52e-1b3677f3d0aa/retry "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/finance-actions/withdrawals/b9e8e571-8724-4eb7-b52e-1b3677f3d0aa/retry "HTTP/1.1 404 Not Found"
__ test_recheck_paid_finalizes_pending_and_writes_single_withdraw_paid_ledger __

client = <httpx.AsyncClient object at 0xf920544c7a90>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    @pytest.mark.asyncio
    async def test_recheck_paid_finalizes_pending_and_writes_single_withdraw_paid_ledger(
        client, async_session_factory
    ):
        tenant, player, admin, admin_token = await _seed_admin_player_and_balance(async_session_factory)
    
        from tests.conftest import _make_player_token
    
        player_token = _make_player_token(player.id, tenant.id)
    
        # Player initiates withdrawal
        headers_player = {"Authorization": f"Bearer {player_token}", "Idempotency-Key": "recheck-paid-wd"}
        r_wd = await client.post(
            "/api/v1/player/wallet/withdraw",
            json={"amount": 30, "method": "bank", "address": "addr"},
            headers=headers_player,
        )
>       assert r_wd.status_code in (200, 201)
E       assert 400 in (200, 201)
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests/test_payout_recheck.py:87: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:12,669 - app.request - INFO - request
2025-12-26 19:03:12,669 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call -------------------------------
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
--------------------------- Captured stderr teardown ---------------------------
2025-12-26 19:03:12,672 - sqlalchemy.pool.impl.AsyncAdaptedQueuePool - ERROR - The garbage collector is trying to clean up non-checked-in connection <AdaptedConnection <Connection(Thread-2, started daemon 273917259542944)>>, which will be dropped, as it cannot be safely terminated.  Please ensure that SQLAlchemy pooled connections are returned to the pool explicitly, either by calling ``close()`` or by using appropriate context managers to manage their lifecycle.
2025-12-26 19:03:12,672 - sqlalchemy.pool.impl.AsyncAdaptedQueuePool - ERROR - The garbage collector is trying to clean up non-checked-in connection <AdaptedConnection <Connection(Thread-1, started daemon 273917271142816)>>, which will be dropped, as it cannot be safely terminated.  Please ensure that SQLAlchemy pooled connections are returned to the pool explicitly, either by calling ``close()`` or by using appropriate context managers to manage their lifecycle.
2025-12-26 19:03:12,672 - sqlalchemy.pool.impl.AsyncAdaptedQueuePool - ERROR - The garbage collector is trying to clean up non-checked-in connection <AdaptedConnection <Connection(Thread-4, started daemon 273917167989152)>>, which will be dropped, as it cannot be safely terminated.  Please ensure that SQLAlchemy pooled connections are returned to the pool explicitly, either by calling ``close()`` or by using appropriate context managers to manage their lifecycle.
2025-12-26 19:03:12,672 - sqlalchemy.pool.impl.AsyncAdaptedQueuePool - ERROR - The garbage collector is trying to clean up non-checked-in connection <AdaptedConnection <Connection(Thread-5, started daemon 273917159535008)>>, which will be dropped, as it cannot be safely terminated.  Please ensure that SQLAlchemy pooled connections are returned to the pool explicitly, either by calling ``close()`` or by using appropriate context managers to manage their lifecycle.
____ test_recheck_failed_transitions_to_payout_failed_and_writes_no_ledger _____

client = <httpx.AsyncClient object at 0xf920544c64d0>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    @pytest.mark.asyncio
    async def test_recheck_failed_transitions_to_payout_failed_and_writes_no_ledger(
        client, async_session_factory
    ):
        tenant, player, admin, admin_token = await _seed_admin_player_and_balance(async_session_factory)
    
        from tests.conftest import _make_player_token
    
        player_token = _make_player_token(player.id, tenant.id)
    
        headers_player = {"Authorization": f"Bearer {player_token}", "Idempotency-Key": "recheck-fail-wd"}
        r_wd = await client.post(
            "/api/v1/player/wallet/withdraw",
            json={"amount": 20, "method": "bank", "address": "addr"},
            headers=headers_player,
        )
>       assert r_wd.status_code in (200, 201)
E       assert 400 in (200, 201)
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests/test_payout_recheck.py:154: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:12,751 - app.request - INFO - request
2025-12-26 19:03:12,752 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call -------------------------------
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
____ test_recheck_pending_outcome_keeps_payout_pending_and_writes_no_ledger ____

client = <httpx.AsyncClient object at 0xf9205460aad0>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    @pytest.mark.asyncio
    async def test_recheck_pending_outcome_keeps_payout_pending_and_writes_no_ledger(
        client, async_session_factory
    ):
        tenant, player, admin, admin_token = await _seed_admin_player_and_balance(async_session_factory)
    
        from tests.conftest import _make_player_token
    
        player_token = _make_player_token(player.id, tenant.id)
    
        headers_player = {"Authorization": f"Bearer {player_token}", "Idempotency-Key": "recheck-pending-wd"}
        r_wd = await client.post(
            "/api/v1/player/wallet/withdraw",
            json={"amount": 15, "method": "bank", "address": "addr"},
            headers=headers_player,
        )
>       assert r_wd.status_code in (200, 201)
E       assert 400 in (200, 201)
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests/test_payout_recheck.py:216: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:12,771 - app.request - INFO - request
2025-12-26 19:03:12,772 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call -------------------------------
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
_______________ test_recheck_replay_same_idempotency_key_is_noop _______________

client = <httpx.AsyncClient object at 0xf920545fa1d0>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    @pytest.mark.asyncio
    async def test_recheck_replay_same_idempotency_key_is_noop(
        client, async_session_factory
    ):
        tenant, player, admin, admin_token = await _seed_admin_player_and_balance(async_session_factory)
    
        from tests.conftest import _make_player_token
    
        player_token = _make_player_token(player.id, tenant.id)
    
        headers_player = {"Authorization": f"Bearer {player_token}", "Idempotency-Key": "recheck-replay-wd"}
        r_wd = await client.post(
            "/api/v1/player/wallet/withdraw",
            json={"amount": 25, "method": "bank", "address": "addr"},
            headers=headers_player,
        )
>       assert r_wd.status_code in (200, 201)
E       assert 400 in (200, 201)
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests/test_payout_recheck.py:278: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:12,790 - app.request - INFO - request
2025-12-26 19:03:12,791 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call -------------------------------
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
________________ test_payout_retry_after_fail_reduces_held_once ________________

client = <httpx.AsyncClient object at 0xf920546eeb90>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    @pytest.mark.asyncio
    async def test_payout_retry_after_fail_reduces_held_once(client, async_session_factory):
        """TCK-P05-RETRY-001: fail -> retry success should drop held exactly once."""
    
        tenant, player, admin, admin_token = await _seed_admin_player_and_balance(async_session_factory)
    
        from tests.conftest import _make_player_token
    
        player_token = _make_player_token(player.id, tenant.id)
    
        # 1) Withdraw 30 (requested)
        headers_player = {"Authorization": f"Bearer {player_token}", "Idempotency-Key": "payout-retry-wd"}
        r_wd = await client.post(
            "/api/v1/player/wallet/withdraw",
            json={"amount": 30, "method": "test_bank", "address": "addr"},
            headers=headers_player,
        )
>       assert r_wd.status_code in (200, 201)
E       assert 400 in (200, 201)
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests/test_payout_retry.py:74: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:12,814 - app.request - INFO - request
2025-12-26 19:03:12,814 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call -------------------------------
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/player/wallet/withdraw "HTTP/1.1 400 Bad Request"
____________ test_deposit_authorize_and_capture_ledger_and_snapshot ____________

client = <httpx.AsyncClient object at 0xf92054540290>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    def test_deposit_authorize_and_capture_ledger_and_snapshot(client, async_session_factory):
        """E1: Deposit triggers authorize + capture ledger events and updates snapshot.
    
        - LedgerTransaction: deposit_authorized + deposit_captured with provider metadata.
        - WalletBalance.balance_real_available increased by deposit amount.
        """
    
        settings.ledger_shadow_write = True
    
        async def _run():
            # Reuse existing helper to seed tenant, player and admin + tokens
            tenant, player, admin, player_token, admin_token = await _seed_admin_and_player(async_session_factory)
            token = player_token
    
            headers = {"Authorization": f"Bearer {token}", "Idempotency-Key": "idem-psp-dep-1"}
            amount = 50.0
            r_dep = client.post(
                "/api/v1/player/wallet/deposit",
                json={"amount": amount, "method": "test"},
                headers=headers,
            )
            assert r_dep.status_code in (200, 201)
    
            async with async_session_factory() as session:
                # Check that exactly one deposit delta (+amount) was applied
                db_player = await session.get(Player, player.id)
                before_plus_amount = db_player.balance_real_available
    
            async with async_session_factory() as session:
                db_player = await session.get(Player, player.id)
                assert db_player.balance_real_available == pytest.approx(before_plus_amount)
    
                wb = (
                    await session.execute(
                        select(WalletBalance).where(
                            WalletBalance.tenant_id == tenant.id,
                            WalletBalance.player_id == player.id,
                            WalletBalance.currency == "USD",
                        )
                    )
                ).scalars().first()
                assert wb is not None
                assert wb.balance_real_available == pytest.approx(amount)
                assert wb.balance_real_pending == pytest.approx(0.0)
    
                evs = (
                    await session.execute(
                        select(LedgerTransaction).where(
                            LedgerTransaction.tenant_id == tenant.id,
                            LedgerTransaction.player_id == player.id,
                            LedgerTransaction.type == "deposit",
                        )
                    )
                ).scalars().all()
                statuses = {e.status for e in evs}
                assert "deposit_authorized" in statuses
                assert "deposit_captured" in statuses
    
                # Provider metadata should be populated
                for e in evs:
                    assert e.provider == "mockpsp"
                    assert e.provider_ref is not None
                    assert e.provider_event_id is not None
    
>       asyncio.run(_run())

tests/test_psp_ledger_integration.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/asyncio/runners.py:190: in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/asyncio/base_events.py:654: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def _run():
        # Reuse existing helper to seed tenant, player and admin + tokens
        tenant, player, admin, player_token, admin_token = await _seed_admin_and_player(async_session_factory)
        token = player_token
    
        headers = {"Authorization": f"Bearer {token}", "Idempotency-Key": "idem-psp-dep-1"}
        amount = 50.0
        r_dep = client.post(
            "/api/v1/player/wallet/deposit",
            json={"amount": amount, "method": "test"},
            headers=headers,
        )
>       assert r_dep.status_code in (200, 201)
               ^^^^^^^^^^^^^^^^^
E       AttributeError: 'coroutine' object has no attribute 'status_code'

tests/test_psp_ledger_integration.py:40: AttributeError
____________ test_mark_paid_adds_psp_metadata_and_finalizes_pending ____________

client = <httpx.AsyncClient object at 0xf920545b4ed0>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    def test_mark_paid_adds_psp_metadata_and_finalizes_pending(client, async_session_factory):
        """E2: Mark-paid triggers PSP payout and finalizes pending balance.
    
        Flow:
        - Deposit 100
        - Withdraw 40 (requested -> approved -> paid)
    
        Expectations:
        - WalletBalance.pending decreases by 40 on paid.
        - withdraw_paid event has provider metadata.
        """
    
        settings.ledger_shadow_write = True
    
        async def _run():
            # Reuse existing helper to seed tenant, player and admin + tokens
            tenant, player, admin, player_token, admin_token = await _seed_admin_and_player(async_session_factory)
            token = player_token
    
            # Fund via deposit 100
            dep_headers = {"Authorization": f"Bearer {token}", "Idempotency-Key": "idem-psp-dep-2"}
            r_dep = client.post(
                "/api/v1/player/wallet/deposit",
                json={"amount": 100.0, "method": "test"},
                headers=dep_headers,
            )
            assert r_dep.status_code in (200, 201)
    
            # Player withdraw 40
            w_headers = {"Authorization": f"Bearer {token}", "Idempotency-Key": "idem-psp-w-1"}
            r_w = client.post(
                "/api/v1/player/wallet/withdraw",
                json={"amount": 40.0, "method": "test_bank", "address": "psp"},
                headers=w_headers,
            )
            assert r_w.status_code in (200, 201)
            tx_id = r_w.json().get("transaction", {}).get("id") or r_w.json().get("tx_id")
            assert tx_id
    
            # Admin approve then mark-paid via finance endpoints using seeded admin token
            admin_headers = {"Authorization": f"Bearer {admin_token}"}
    
            r_rev = client.post(
                f"/api/v1/finance/withdrawals/{tx_id}/review",
                json={"action": "approve"},
                headers=admin_headers,
            )
            assert r_rev.status_code in (200, 201)
    
            r_paid = client.post(
                f"/api/v1/finance/withdrawals/{tx_id}/mark-paid",
                headers=admin_headers,
            )
            assert r_paid.status_code in (200, 201)
    
            async with async_session_factory() as session:
                wb = (
                    await session.execute(
                        select(WalletBalance).where(
                            WalletBalance.tenant_id == tenant.id,
                            WalletBalance.player_id == player.id,
                            WalletBalance.currency == "USD",
                        )
                    )
                ).scalars().first()
                assert wb is not None
                assert wb.balance_real_pending == pytest.approx(0.0)
    
                evs = (
                    await session.execute(
                        select(LedgerTransaction).where(
                            LedgerTransaction.tenant_id == tenant.id,
                            LedgerTransaction.player_id == player.id,
                            LedgerTransaction.type == "withdraw",
                            LedgerTransaction.status == "withdraw_paid",
                        )
                    )
                ).scalars().all()
                assert len(evs) >= 1
                for e in evs:
                    assert e.provider == "mockpsp"
                    assert e.provider_ref is not None
                    assert e.provider_event_id is not None
    
>       asyncio.run(_run())

tests/test_psp_ledger_integration.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/asyncio/runners.py:190: in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/asyncio/base_events.py:654: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def _run():
        # Reuse existing helper to seed tenant, player and admin + tokens
        tenant, player, admin, player_token, admin_token = await _seed_admin_and_player(async_session_factory)
        token = player_token
    
        # Fund via deposit 100
        dep_headers = {"Authorization": f"Bearer {token}", "Idempotency-Key": "idem-psp-dep-2"}
        r_dep = client.post(
            "/api/v1/player/wallet/deposit",
            json={"amount": 100.0, "method": "test"},
            headers=dep_headers,
        )
>       assert r_dep.status_code in (200, 201)
               ^^^^^^^^^^^^^^^^^
E       AttributeError: 'coroutine' object has no attribute 'status_code'

tests/test_psp_ledger_integration.py:113: AttributeError
____________________ test_findings_list_requires_admin_auth ____________________

client = <httpx.AsyncClient object at 0xf920544c6410>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    def test_findings_list_requires_admin_auth(client, async_session_factory):
        # Anonymous request should fail
        r = client.get("/api/v1/payments/reconciliation/findings")
>       assert r.status_code in (401, 403)
               ^^^^^^^^^^^^^
E       AttributeError: 'coroutine' object has no attribute 'status_code'

tests/test_psp_reconciliation_api.py:19: AttributeError
__________________ test_findings_list_filters_and_pagination ___________________

client = <httpx.AsyncClient object at 0xf9205443ca50>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    def test_findings_list_filters_and_pagination(client, async_session_factory):
        tenant, player, admin, player_token, admin_token = asyncio.run(_seed_admin_and_player(async_session_factory))
    
        async def _seed_findings():
            async with async_session_factory() as session:
                f1 = ReconciliationFinding(
                    provider="mockpsp",
                    tenant_id=tenant.id,
                    player_id=player.id,
                    tx_id="tx-1",
                    provider_event_id="evt-1",
                    finding_type="missing_in_ledger",
                    severity="WARN",
                    status="OPEN",
                    message="test1",
                )
                f2 = ReconciliationFinding(
                    provider="mockpsp",
                    tenant_id=tenant.id,
                    player_id=player.id,
                    tx_id="tx-2",
                    provider_event_id="evt-2",
                    finding_type="missing_in_psp",
                    severity="INFO",
                    status="RESOLVED",
                    message="test2",
                )
                session.add(f1)
                session.add(f2)
                await session.commit()
    
        asyncio.run(_seed_findings())
    
        headers_admin = {"Authorization": f"Bearer {admin_token}"}
    
        r = client.get(
            "/api/v1/payments/reconciliation/findings",
            params={"provider": "mockpsp", "status": "OPEN", "limit": 10, "offset": 0},
            headers=headers_admin,
        )
>       assert r.status_code == 200
               ^^^^^^^^^^^^^
E       AttributeError: 'coroutine' object has no attribute 'status_code'

tests/test_psp_reconciliation_api.py:63: AttributeError
_______________________ test_findings_resolve_happy_path _______________________

client = <httpx.AsyncClient object at 0xf9205453e8d0>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    def test_findings_resolve_happy_path(client, async_session_factory):
        tenant, player, admin, player_token, admin_token = asyncio.run(_seed_admin_and_player(async_session_factory))
    
        async def _seed_open_finding():
            async with async_session_factory() as session:
                f = ReconciliationFinding(
                    provider="mockpsp",
                    tenant_id=tenant.id,
                    player_id=player.id,
                    tx_id="tx-open",
                    provider_event_id="evt-open",
                    finding_type="missing_in_ledger",
                    severity="WARN",
                    status="OPEN",
                )
                session.add(f)
                await session.commit()
                await session.refresh(f)
                return f.id
    
        finding_id = asyncio.run(_seed_open_finding())
    
        headers_admin = {"Authorization": f"Bearer {admin_token}"}
    
        r = client.post(
            f"/api/v1/payments/reconciliation/findings/{finding_id}/resolve",
            headers=headers_admin,
        )
>       assert r.status_code == 200
               ^^^^^^^^^^^^^
E       AttributeError: 'coroutine' object has no attribute 'status_code'

tests/test_psp_reconciliation_api.py:99: AttributeError
__________________________ test_findings_resolve_404 ___________________________

client = <httpx.AsyncClient object at 0xf9205448f310>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    def test_findings_resolve_404(client, async_session_factory):
        tenant, player, admin, player_token, admin_token = asyncio.run(_seed_admin_and_player(async_session_factory))
        headers_admin = {"Authorization": f"Bearer {admin_token}"}
    
        r = client.post(
            "/api/v1/payments/reconciliation/findings/non-existent-id/resolve",
            headers=headers_admin,
        )
>       assert r.status_code == 404
               ^^^^^^^^^^^^^
E       AttributeError: 'coroutine' object has no attribute 'status_code'

tests/test_psp_reconciliation_api.py:122: AttributeError
___________ test_webhook_replay_guard_and_ledger_mapping_for_deposit ___________

client = <httpx.AsyncClient object at 0xf920544bd550>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    def test_webhook_replay_guard_and_ledger_mapping_for_deposit(client, async_session_factory):
        """PSP-02E: Deposit webhook -> ledger events + replay guard.
    
        - First webhook call should append a single deposit ledger event and apply
          delta once (created-gated).
        - Second call with same provider_event_id is a no-op at ledger level.
        """
    
        settings.ledger_shadow_write = True
    
        async def _seed():
            async with async_session_factory() as session:
                tenant = await _create_tenant(session)
                player = await _create_player(session, tenant.id, kyc_status="verified", balance_available=0.0)
                return tenant, player
    
        tenant, player = asyncio.run(_seed())
    
        payload = {
            "provider_event_id": "evt-psp-dep-1",
            "event_type": "deposit_captured",
            "player_id": player.id,
            "tenant_id": tenant.id,
            "amount": 30.0,
            "currency": "USD",
            "tx_id": "tx-psp-dep-1",
        }
    
        # First call -> ledger event + delta
        r1 = client.post("/api/v1/payments/webhook/mockpsp", json=payload)
>       assert r1.status_code == 200
               ^^^^^^^^^^^^^^
E       AttributeError: 'coroutine' object has no attribute 'status_code'

tests/test_psp_webhooks.py:48: AttributeError
________ test_withdraw_paid_webhook_finalizes_pending_and_is_idempotent ________

client = <httpx.AsyncClient object at 0xf92054331790>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    def test_withdraw_paid_webhook_finalizes_pending_and_is_idempotent(client, async_session_factory):
        """W1: withdraw_paid webhook maps to ledger + pending finalize (created-gated)."""
    
        settings.ledger_shadow_write = True
    
        async def _seed():
            async with async_session_factory() as session:
                tenant = await _create_tenant(session)
                player = await _create_player(session, tenant.id, kyc_status="verified", balance_available=0.0)
                return tenant, player
    
        tenant, player = asyncio.run(_seed())
    
        # Seed wallet with 100 and create a pending withdraw of 40 via existing flow
        # Deposit 100
        dep_headers = {"Authorization": f"Bearer {_make_player_token(player.id, tenant.id)}", "Idempotency-Key": "idem-psp-w-dep"}
        r_dep = client.post(
            "/api/v1/player/wallet/deposit",
            json={"amount": 100.0, "method": "test"},
            headers=dep_headers,
        )
>       assert r_dep.status_code in (200, 201)
               ^^^^^^^^^^^^^^^^^
E       AttributeError: 'coroutine' object has no attribute 'status_code'

tests/test_psp_webhooks.py:108: AttributeError
___________ test_api_key_create_returns_secret_once_but_not_in_list ____________

    def test_api_key_create_returns_secret_once_but_not_in_list():
        api = _api_base()
        token = _login_token()
    
        # Create should return api_key once
        r = requests.post(
            f"{api}/api/v1/api-keys/",
            json={"name": "Leak Test", "scopes": ["robot.run"]},
            headers={"Authorization": f"Bearer {token}"},
            timeout=30,
        )
>       assert r.status_code == 200, r.text
E       AssertionError: {"error_code":"INTERNAL_SERVER_ERROR","message":"An unexpected error occurred.","details":{"error":"cannot import name 'generate_api_key' from 'app.utils.api_keys' (/app/backend/app/utils/api_keys.py)"},"timestamp":"2025-12-26T19:03:14.536917"}
E       assert 500 == 200
E        +  where 500 = <Response [500]>.status_code

tests/test_response_dto_leaks.py:81: AssertionError
______________________ test_seed_on_startup_default_false ______________________

    def test_seed_on_startup_default_false():
        settings = _reload_settings("dev", None)
>       assert settings.seed_on_startup is False
E       AssertionError: assert True is False
E        +  where True = Settings(env='dev', database_url='sqlite+aiosqlite:////app/backend/casino.db', db_pool_size=5, db_max_overflow=10, jwt...tripe_webhook_secret=None, adyen_api_key=None, adyen_merchant_account=None, adyen_client_key=None, adyen_hmac_key=None).seed_on_startup

tests/test_seeding_guard.py:21: AssertionError
________________________________ test_sql_logic ________________________________
async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted
___________________ test_audit_payload_for_withdraw_request ____________________

client = <httpx.AsyncClient object at 0xf920541ae550>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    def test_audit_payload_for_withdraw_request(client, async_session_factory):
        async def seed():
            async with async_session_factory() as session:
                tenant = await _create_tenant(session)
                player = await _create_player(session, tenant.id, kyc_status="verified", balance_available=100)
                token = _make_player_token(player.id, tenant.id)
                return tenant, player, token
    
        import asyncio
    
        tenant, player, token = asyncio.run(seed())
    
        headers = {"Authorization": f"Bearer {token}", "Idempotency-Key": "wd-audit-001"}
        r = client.post(
            "/api/v1/player/wallet/withdraw",
            json={"amount": 20, "method": "bank", "address": "addr"},
            headers=headers,
        )
>       assert r.status_code in (200, 201)
               ^^^^^^^^^^^^^
E       AttributeError: 'coroutine' object has no attribute 'status_code'

tests/test_wallet_audit_payload.py:34: AttributeError
______ test_deposit_idempotency_same_key_returns_same_tx_and_no_duplicate ______

client = <httpx.AsyncClient object at 0xf92054162850>
player_with_token = (Tenant(id='404e9877-fdb0-4e1a-83d4-dfcc526b569c', name='Test Casino', created_at=datetime.datetime(2025, 12, 26, 19, ...WEtODNkNC1kZmNjNTI2YjU2OWMiLCJyb2xlIjoicGxheWVyIiwiZXhwIjoxNzY2ODYyMjAyfQ.-3QQMkWKhAgakbzlikVIF10N4D75Hnb8c8t6-4B16kQ')

    @pytest.mark.usefixtures("client", "player_with_token")
    def test_deposit_idempotency_same_key_returns_same_tx_and_no_duplicate(client, player_with_token):
        tenant, player, token = player_with_token
    
        headers = {"Authorization": f"Bearer {token}", "Idempotency-Key": "key-123"}
    
        # First deposit
        r1 = client.post("/api/v1/player/wallet/deposit", json={"amount": 10, "method": "card"}, headers=headers)
>       assert r1.status_code in (200, 201)
               ^^^^^^^^^^^^^^
E       AttributeError: 'coroutine' object has no attribute 'status_code'

tests/test_wallet_idempotency_deposit.py:16: AttributeError
___________________________ test_kyc_withdraw_block ____________________________

client = <httpx.AsyncClient object at 0xf9205416d810>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)

    @pytest.mark.usefixtures("client")
    def test_kyc_withdraw_block(client, async_session_factory):
        # Create unverified player
        async def seed():
            async with async_session_factory() as session:
                tenant = await _create_tenant(session)
                player = await _create_player(session, tenant.id, kyc_status="pending")
                token = _make_player_token(player.id, tenant.id)
                return player, token
    
        import asyncio
    
        player, token = asyncio.run(seed())
    
        headers = {"Authorization": f"Bearer {token}", "Idempotency-Key": "wd-kyc-001"}
        r = client.post(
            "/api/v1/player/wallet/withdraw",
            json={"amount": 10, "method": "bank", "address": "addr"},
            headers=headers,
        )
>       assert r.status_code == 403
               ^^^^^^^^^^^^^
E       AttributeError: 'coroutine' object has no attribute 'status_code'

tests/test_wallet_kyc_withdraw_block.py:33: AttributeError
_________________________ test_unverified_deposit_cap __________________________

client = <httpx.AsyncClient object at 0xf92054178910>
async_session_factory = async_sessionmaker(class_='AsyncSession', bind=<sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0xf920561b24c0>, autoflush=True, expire_on_commit=False)
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0xf92054178450>

    @pytest.mark.usefixtures("client")
    def test_unverified_deposit_cap(client, async_session_factory, monkeypatch):
        # Set cap to 100 for test
        monkeypatch.setenv("KYC_UNVERIFIED_DAILY_DEPOSIT_CAP", "100")
    
        async def seed():
            async with async_session_factory() as session:
                tenant = await _create_tenant(session)
                # Unverified player
                player = await _create_player(session, tenant.id, kyc_status="pending")
                token = _make_player_token(player.id, tenant.id)
                return player, token
    
        import asyncio
    
        player, token = asyncio.run(seed())
    
        headers = {"Authorization": f"Bearer {token}", "Idempotency-Key": "dep-cap-1"}
    
        # First deposit within cap
        r1 = client.post(
            "/api/v1/player/wallet/deposit",
            json={"amount": 60, "method": "card"},
            headers=headers,
        )
>       assert r1.status_code in (200, 201)
               ^^^^^^^^^^^^^^
E       AttributeError: 'coroutine' object has no attribute 'status_code'

tests/test_wallet_unverified_deposit_cap.py:39: AttributeError
____________________ test_stripe_webhook_signature_failure _____________________

client = <httpx.AsyncClient object at 0xf920541cb6d0>
session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xf920541d5090>

    @pytest.mark.asyncio
    async def test_stripe_webhook_signature_failure(client: AsyncClient, session):
        """
        Test that invalid signature returns 401/400.
        """
        with patch("config.settings.webhook_signature_enforced", True):
            with patch("config.settings.stripe_webhook_secret", "whsec_test"):
                # We need to mock the stripe.Webhook.construct_event to raise error
                with patch("stripe.Webhook.construct_event", side_effect=stripe.error.SignatureVerificationError("Invalid sig", "sig", "body")):
                    resp = await client.post(
                        "/api/v1/payments/stripe/webhook",
                        content=b"{}",
                        headers={"stripe-signature": "invalid"}
                    )
                    # The code catches Exception and raises 400
                    assert resp.status_code == 400
>                   assert "Webhook Error" in resp.json()["detail"]
E                   AssertionError: assert 'Webhook Error' in 'Could not parse event'

tests/test_webhook_security_stripe.py:25: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:22,168 - app.request - INFO - request
2025-12-26 19:03:22,169 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/payments/stripe/webhook "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call -------------------------------
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/payments/stripe/webhook "HTTP/1.1 400 Bad Request"
____________________ test_stripe_webhook_replay_protection _____________________

client = <httpx.AsyncClient object at 0xf92054182110>
session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xf92054181dd0>

    @pytest.mark.asyncio
    async def test_stripe_webhook_replay_protection(client: AsyncClient, session):
        """
        Test that replaying the same webhook (same provider_event_id) returns 200 no-op.
        """
        # 1. Create a completed transaction first
        tx = Transaction(
            tenant_id="default_casino",
            player_id="player1",
            type="deposit",
            amount=100.0,
            currency="USD",
            status="completed",
            state="completed",
            provider="stripe",
            provider_event_id="evt_replay_test"
        )
        session.add(tx)
        await session.commit()
    
        # 2. Mock construct_event to return an event with that ID
        mock_event = MagicMock()
        mock_event.type = "checkout.session.completed"
    
        # Nested mock object for data.object.id
        mock_session_obj = MagicMock()
        mock_session_obj.id = "evt_replay_test"
        mock_event.data.object = mock_session_obj
    
        with patch("config.settings.stripe_webhook_secret", "whsec_test"):
             with patch("stripe.Webhook.construct_event", return_value=mock_event):
                resp = await client.post(
                    "/api/v1/payments/stripe/webhook",
                    content=b"{}",
                    headers={"stripe-signature": "valid"}
                )
    
>               assert resp.status_code == 200
E               assert 400 == 200
E                +  where 400 = <Response [400 Bad Request]>.status_code

tests/test_webhook_security_stripe.py:64: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:22,180 - app.request - INFO - request
2025-12-26 19:03:22,181 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/payments/stripe/webhook "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call -------------------------------
INFO     app.request:request_logging.py:62 request
INFO     httpx:_client.py:1740 HTTP Request: POST http://testserver/api/v1/payments/stripe/webhook "HTTP/1.1 400 Bad Request"
________________________ test_run_daily_reconciliation _________________________

session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0xf920541839d0>

    @pytest.mark.asyncio
    async def test_run_daily_reconciliation(session):
        """
        Test that the daily reconciliation worker:
        1. Creates ReconciliationRun records for all providers
        2. Calls the execution job
        """
    
        # We need to mock get_session to return our test session
        # Since run_daily_reconciliation iterates over get_session(), we need to mock it as an async generator
        async def mock_get_session_gen():
            yield session
    
        with patch("app.worker.get_session", side_effect=mock_get_session_gen):
            # Mock the actual job execution to avoid complex logic/side effects
            with patch("app.worker.run_reconciliation_for_run_id", new_callable=AsyncMock) as mock_job:
    
                # Execute worker function
                await run_daily_reconciliation(None)
    
                # Verify DB records
                stmt = select(ReconciliationRun)
                runs = (await session.execute(stmt)).scalars().all()
    
                # Expect at least 2 runs (stripe, adyen)
                assert len(runs) >= 2
    
                providers = {r.provider for r in runs}
                assert "stripe" in providers
                assert "adyen" in providers
    
                # Verify job was called for each run
>               assert mock_job.call_count == len(runs)
E               AssertionError: assert 2 == 6
E                +  where 2 = <AsyncMock name='run_reconciliation_for_run_id' id='273917244838160'>.call_count
E                +  and   6 = len([ReconciliationRun(id='ad6bd6bb-87a6-4514-b5a0-5e7dac67d493', window_end=datetime.datetime(2025, 12, 27, 0, 0), provid...ime.datetime(2025, 12, 25, 0, 0), idempotency_key=None, updated_at=datetime.datetime(2025, 12, 26, 19, 3, 22, 193395))])

tests/test_worker_recon.py:39: AssertionError
----------------------------- Captured stderr call -----------------------------
2025-12-26 19:03:22,185 - app.worker - INFO - Starting daily reconciliation cron job
2025-12-26 19:03:22,192 - app.worker - INFO - Daily reconciliation for stripe completed. Status: queued
2025-12-26 19:03:22,198 - app.worker - INFO - Daily reconciliation for adyen completed. Status: queued
------------------------------ Captured log call -------------------------------
INFO     app.worker:worker.py:29 Starting daily reconciliation cron job
INFO     app.worker:worker.py:67 Daily reconciliation for stripe completed. Status: queued
INFO     app.worker:worker.py:67 Daily reconciliation for adyen completed. Status: queued
=============================== warnings summary ===============================
../../root/.venv/lib/python3.11/site-packages/pydantic/_internal/_config.py:295
backend/tests/test_seeding_guard.py::test_seed_on_startup_default_false
backend/tests/test_seeding_guard.py::test_seed_on_startup_true_when_env_var_set
backend/tests/test_seeding_guard.py::test_seed_never_runs_in_prod_even_if_flag_set
  /root/.venv/lib/python3.11/site-packages/pydantic/_internal/_config.py:295: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.10/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../root/.venv/lib/python3.11/site-packages/pydantic/_migration.py:283
  /root/.venv/lib/python3.11/site-packages/pydantic/_migration.py:283: UserWarning: `pydantic.generics:GenericModel` has been moved to `pydantic.BaseModel`.
    warnings.warn(f'`{import_path}` has been moved to `{new_location}`.')

../../root/.venv/lib/python3.11/site-packages/emergentintegrations/payments/stripe/checkout.py:24
  /root/.venv/lib/python3.11/site-packages/emergentintegrations/payments/stripe/checkout.py:24: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.10/migration/
    @validator('amount')

../../root/.venv/lib/python3.11/site-packages/emergentintegrations/payments/stripe/checkout.py:30
  /root/.venv/lib/python3.11/site-packages/emergentintegrations/payments/stripe/checkout.py:30: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.10/migration/
    @validator('quantity')

../../root/.venv/lib/python3.11/site-packages/emergentintegrations/payments/stripe/checkout.py:36
  /root/.venv/lib/python3.11/site-packages/emergentintegrations/payments/stripe/checkout.py:36: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.10/migration/
    @validator('stripe_price_id')

../../root/.venv/lib/python3.11/site-packages/emergentintegrations/payments/stripe/checkout.py:44
  /root/.venv/lib/python3.11/site-packages/emergentintegrations/payments/stripe/checkout.py:44: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.10/migration/
    @validator('payment_methods')

server.py:158
  /app/backend/server.py:158: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../root/.venv/lib/python3.11/site-packages/fastapi/applications.py:4495
../../root/.venv/lib/python3.11/site-packages/fastapi/applications.py:4495
../../root/.venv/lib/python3.11/site-packages/fastapi/applications.py:4495
  /root/.venv/lib/python3.11/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

server.py:255
  /app/backend/server.py:255: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("shutdown")

server.py:272
  /app/backend/server.py:272: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("shutdown")

backend/tests/test_finance_withdraw_admin_api.py::test_approve_requested_withdraw_does_not_change_balance
  /root/.venv/lib/python3.11/site-packages/starlette/middleware/base.py:120: RuntimeWarning: coroutine 'AsyncClient.post' was never awaited
    async with anyio.create_task_group() as task_group:
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

backend/tests/test_reconciliation.py::test_duplicate_withdraw_paid_finding
  /root/.venv/lib/python3.11/site-packages/sqlalchemy/orm/context.py:2786: RuntimeWarning: coroutine 'AsyncClient.get' was never awaited
    _instance = loading._instance_processor(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

backend/tests/test_reconciliation.py::test_duplicate_withdraw_paid_finding
  /root/.venv/lib/python3.11/site-packages/sqlalchemy/orm/context.py:2786: RuntimeWarning: coroutine 'AsyncClient.post' was never awaited
    _instance = loading._instance_processor(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

backend/tests/test_refund_flow.py::test_admin_refund_invalid_state
  <string>:23: SAWarning: The garbage collector is trying to clean up non-checked-in connection <AdaptedConnection <Connection(Thread-8, started daemon 273917142626720)>>, which will be dropped, as it cannot be safely terminated.  Please ensure that SQLAlchemy pooled connections are returned to the pool explicitly, either by calling ``close()`` or by using appropriate context managers to manage their lifecycle.

backend/tests/test_refund_flow.py::test_admin_refund_invalid_state
  <string>:23: SAWarning: The garbage collector is trying to clean up non-checked-in connection <AdaptedConnection <Connection(Thread-9, started daemon 273917134172576)>>, which will be dropped, as it cannot be safely terminated.  Please ensure that SQLAlchemy pooled connections are returned to the pool explicitly, either by calling ``close()`` or by using appropriate context managers to manage their lifecycle.

backend/tests/test_webhook_security_stripe.py::test_stripe_webhook_signature_failure
  /usr/local/lib/python3.11/asyncio/base_events.py:437: RuntimeWarning: coroutine 'AsyncClient.post' was never awaited
    task = tasks.Task(coro, loop=self, name=name, context=context)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/test_callback_security.py::test_callback_security_negative - ass...
FAILED tests/test_engine_only.py::test_engine - Failed: async def functions a...
FAILED tests/test_finance_webhook_idempotency.py::test_webhook_idempotency - ...
FAILED tests/test_finance_withdraw_admin_api.py::test_approve_requested_withdraw_does_not_change_balance
FAILED tests/test_finance_withdraw_admin_api.py::test_mark_paid_from_approved_reduces_held
FAILED tests/test_finance_withdraw_admin_api.py::test_invalid_state_transitions_return_409
FAILED tests/test_ledger_repo.py::test_append_event_idempotency_client - Asse...
FAILED tests/test_ledger_shadow_flows.py::test_withdraw_requested_creates_hold_in_player_and_ledger
FAILED tests/test_ledger_shadow_flows.py::test_withdraw_idempotent_request_does_not_double_apply_hold
FAILED tests/test_payout_flow.py::test_payout_success_transitions_to_paid_and_writes_single_withdraw_paid_ledger
FAILED tests/test_payout_flow.py::test_payout_fail_transitions_to_payout_failed_and_writes_no_ledger
FAILED tests/test_payout_flow.py::test_payout_replay_same_idempotency_key_no_duplicate_ledger_or_attempt
FAILED tests/test_payout_flow.py::test_payout_webhook_replay_no_duplicate_paid_ledger
FAILED tests/test_payout_flow.py::test_payout_webhook_replay_no_duplicate_effect_failed
FAILED tests/test_payout_provider.py::test_payout_provider_mock_gated_in_prod
FAILED tests/test_payout_provider.py::test_payout_provider_mock_allowed_in_dev
FAILED tests/test_payout_recheck.py::test_recheck_paid_finalizes_pending_and_writes_single_withdraw_paid_ledger
FAILED tests/test_payout_recheck.py::test_recheck_failed_transitions_to_payout_failed_and_writes_no_ledger
FAILED tests/test_payout_recheck.py::test_recheck_pending_outcome_keeps_payout_pending_and_writes_no_ledger
FAILED tests/test_payout_recheck.py::test_recheck_replay_same_idempotency_key_is_noop
FAILED tests/test_payout_retry.py::test_payout_retry_after_fail_reduces_held_once
FAILED tests/test_psp_ledger_integration.py::test_deposit_authorize_and_capture_ledger_and_snapshot
FAILED tests/test_psp_ledger_integration.py::test_mark_paid_adds_psp_metadata_and_finalizes_pending
FAILED tests/test_psp_reconciliation_api.py::test_findings_list_requires_admin_auth
FAILED tests/test_psp_reconciliation_api.py::test_findings_list_filters_and_pagination
FAILED tests/test_psp_reconciliation_api.py::test_findings_resolve_happy_path
FAILED tests/test_psp_reconciliation_api.py::test_findings_resolve_404 - Attr...
FAILED tests/test_psp_webhooks.py::test_webhook_replay_guard_and_ledger_mapping_for_deposit
FAILED tests/test_psp_webhooks.py::test_withdraw_paid_webhook_finalizes_pending_and_is_idempotent
FAILED tests/test_response_dto_leaks.py::test_api_key_create_returns_secret_once_but_not_in_list
FAILED tests/test_seeding_guard.py::test_seed_on_startup_default_false - Asse...
FAILED tests/test_sql_architecture.py::test_sql_logic - Failed: async def fun...
FAILED tests/test_wallet_audit_payload.py::test_audit_payload_for_withdraw_request
FAILED tests/test_wallet_idempotency_deposit.py::test_deposit_idempotency_same_key_returns_same_tx_and_no_duplicate
FAILED tests/test_wallet_kyc_withdraw_block.py::test_kyc_withdraw_block - Att...
FAILED tests/test_wallet_unverified_deposit_cap.py::test_unverified_deposit_cap
FAILED tests/test_webhook_security_stripe.py::test_stripe_webhook_signature_failure
FAILED tests/test_webhook_security_stripe.py::test_stripe_webhook_replay_protection
FAILED tests/test_worker_recon.py::test_run_daily_reconciliation - AssertionE...
39 failed, 92 passed, 1 skipped, 21 warnings in 12.17s

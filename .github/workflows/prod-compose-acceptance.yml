name: Prod Compose Acceptance (Postgres + Migrations)

on:
  push:
    branches: [ "main", "master" ]
  pull_request:
  workflow_dispatch:

jobs:
  prod_compose_acceptance:
    if: ${{ github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository }}
    runs-on: ubuntu-latest
    timeout-minutes: 25

    env:
      # CI acceptance environment (prod/staging secret gates should NOT run here)
      ENV: ci
      SEED_ON_STARTUP: "false"
      DEBUG: "false"
      LOG_FORMAT: json
      LOG_LEVEL: INFO

      # CI için dummy secret yeterli; prod’da GitHub Secrets kullanın
      JWT_SECRET: "ci_dummy_secret_change_me"

      # NOTE: We deliberately do NOT provide payment/webhook secrets in CI acceptance.
      # Prod/staging secret gates should not run under ENV=ci.

      # Bootstrap credentials are set in a step (either from secrets or generated ephemerally)
      # to avoid CI failing when repository secrets are not configured.

      # docker-compose.prod.yml backend port mapping: 8001:8001
      # Use 127.0.0.1 (not localhost) to avoid IPv6/::1 resolution issues in CI Playwright/browser networking
      API_BASE: "http://127.0.0.1:8001"

      # docker-compose.prod.yml postgres env uses POSTGRES_PASSWORD
      POSTGRES_PASSWORD: "postgres"

      # CI db connection string (service name is 'postgres' in compose)
      DATABASE_URL: "postgresql+asyncpg://postgres:postgres@postgres:5432/casino_db"

      # Sync DSN for Alembic/psycopg2 (must match POSTGRES_PASSWORD above)
      SYNC_DATABASE_URL: "postgresql://postgres:postgres@postgres:5432/casino_db"

      # Redis is optional for this release gate (Admin+Backend only)
      REDIS_REQUIRED: "false"

      DB_POOL_SIZE: "5"
      DB_MAX_OVERFLOW: "10"

      # CORS: Explicit allowlist for CI (no wildcard) to match prod/staging rules
      # Browser origin will be http://localhost:3000
      CORS_ORIGINS: "http://localhost:3000,http://127.0.0.1:3000"


      # Frontend build args
      # Browser should talk same-origin (frontend nginx proxies /api -> backend)
      REACT_APP_BACKEND_URL: "http://localhost:3000"
      # Build metadata
      APP_VERSION: "0.0.0-ci"
      GIT_SHA: "ci"
      BUILD_TIME: "ci"

      VITE_API_URL: "http://localhost:3000/api/v1"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Assert expected drift-guard migration exists (P0)
        run: |
          set -euo pipefail
          test -f backend/alembic/versions/20251231_02_schema_drift_guard.py
          echo "OK: drift-guard migration file present"
          echo "CHECKOUT_SHA=$(git rev-parse HEAD)"
      - name: Show Docker versions
        run: |
          docker version
          docker compose version

      - name: Set CI admin credentials (deterministic)
        if: ${{ github.event_name != 'pull_request' }}
        run: |
          set -euo pipefail

          # Deterministic CI admin credentials.
          # CI should not rely on prod/staging bootstrap behavior.
          EMAIL="admin@casino.com"
          PASS="Admin123!"

          echo "BOOTSTRAP_ENABLED=false" >> "$GITHUB_ENV"
          echo "BOOTSTRAP_OWNER_EMAIL=$EMAIL" >> "$GITHUB_ENV"
          echo "BOOTSTRAP_OWNER_PASSWORD=$PASS" >> "$GITHUB_ENV"

          # Keep E2E credentials in sync
          echo "E2E_OWNER_EMAIL=$EMAIL" >> "$GITHUB_ENV"
          echo "E2E_OWNER_PASSWORD=$PASS" >> "$GITHUB_ENV"


      - name: Bring up prod stack (fresh)
        run: |
          set -e
          set -o pipefail

          mkdir -p ci_artifacts

          # Ensure backend/.env does not hard-fail compose on some runners
          if [ -f backend/.env.example ] && [ ! -f backend/.env ]; then
            cp backend/.env.example backend/.env
          fi
          if [ ! -f backend/.env ]; then
            touch backend/.env
          fi


          # Fresh DB için volume’ları sil
          docker compose -f docker-compose.prod.yml --profile localdb down -v --remove-orphans || true

          # Runner disk / build cache kaynaklı fail’leri minimize et
          docker system prune -af || true
          docker buildx prune -af || true

          # BuildKit output'u root-cause'u net gösterir (stack trace yerine gerçek fail-to-solve)
          # Ayrıca build output'u artifact'e yazıyoruz ki tek seferde RCA yapılabilsin.
          set +e
          DOCKER_BUILDKIT=1 docker compose -f docker-compose.prod.yml --profile localdb --profile player build --build-arg CI=false --pull --no-cache --progress=plain | tee ci_artifacts/compose_build.log
          build_rc=${PIPESTATUS[0]}
          set -e

          if [ "$build_rc" != "0" ]; then
            echo "=== BUILD FAILED: LAST 250 LINES (compose_build.log) ==="
            tail -n 250 ci_artifacts/compose_build.log || true
            echo "=== BUILD FAILED: GREP ROOT-CAUSE CANDIDATES ==="
            grep -E "ERROR: failed to solve:|failed to solve:|COPY failed|no space left on device|engine \"node\" is incompatible|pull access denied|manifest unknown|Cannot connect to the Docker daemon" ci_artifacts/compose_build.log | tail -n 80 || true
            exit 1
          fi

          docker compose -f docker-compose.prod.yml --profile localdb --profile player up -d --remove-orphans
          docker compose -f docker-compose.prod.yml --profile localdb --profile player ps | tee ci_artifacts/compose_ps_inline.txt
          docker compose -f docker-compose.prod.yml --profile localdb --profile player logs --no-color --tail=200 | tee ci_artifacts/compose_logs_inline_tail200.txt || true
          docker ps -a

      - name: Wait for API readiness
        run: |
          set -e
          for i in {1..60}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "$API_BASE/api/ready" || true)
            if [ "$code" = "200" ]; then
              echo "Ready OK"
              exit 0
            fi
            echo "Waiting for /api/ready ... ($i) code=$code"
            sleep 2
          done

          echo "Readiness did not become ready in time"
          echo "=== docker compose ps ==="
          docker compose -f docker-compose.prod.yml --profile localdb ps || true
          echo "=== backend logs (tail 200) ==="
          docker compose -f docker-compose.prod.yml --profile localdb logs --no-color --tail=200 backend || true
          echo "=== postgres logs (tail 200) ==="
          docker compose -f docker-compose.prod.yml --profile localdb logs --no-color --tail=200 postgres || true
          exit 1

      - name: Seed deterministic CI admin user
        run: |
          set -euo pipefail

      - name: Assert migrations at head + critical columns present (P0)
        run: |
          set -euo pipefail

          echo "== alembic heads (local) =="
          docker compose -f docker-compose.prod.yml --profile localdb exec -T backend sh -lc 'alembic heads'

          echo "== alembic current (db) =="
          docker compose -f docker-compose.prod.yml --profile localdb exec -T backend sh -lc 'alembic current'

          HEAD="$(docker compose -f docker-compose.prod.yml --profile localdb exec -T backend sh -lc 'alembic heads | head -n 1 | cut -d " " -f1')"
          CURR="$(docker compose -f docker-compose.prod.yml --profile localdb exec -T backend sh -lc 'alembic current | head -n 1 | cut -d " " -f1')"

          echo "HEAD=$HEAD"
          echo "CURR=$CURR"
          test -n "$HEAD" && test -n "$CURR"
          test "$HEAD" = "$CURR"

          echo "== critical columns guard =="

          MISSING_COUNT=$(docker compose -f docker-compose.prod.yml --profile localdb exec -T postgres \
            psql -U postgres -d casino_db -tA -v ON_ERROR_STOP=1 -c "\
              WITH required(table_name, column_name) AS (\
                VALUES\
                  ('player','wagering_requirement'),\
                  ('player','wagering_remaining'),\
                  ('auditevent','actor_role'),\
                  ('auditevent','status')\
              ),\
              missing AS (\
                SELECT r.table_name, r.column_name\
                FROM required r\
                LEFT JOIN information_schema.columns c\
                  ON c.table_schema='public'\
                 AND c.table_name = r.table_name\
                 AND c.column_name = r.column_name\
                WHERE c.column_name IS NULL\
              )\
              SELECT COUNT(*) FROM missing;\
            ")

          echo "MISSING_COUNT=${MISSING_COUNT}"

          if [ "${MISSING_COUNT}" -eq 0 ]; then
            echo "PASS: All critical columns present"
          else
            echo "FAIL: Missing critical columns (${MISSING_COUNT})"
            docker compose -f docker-compose.prod.yml --profile localdb exec -T postgres \
              psql -U postgres -d casino_db -v ON_ERROR_STOP=1 -c "\
                WITH required(table_name, column_name) AS (\
                  VALUES\
                    ('player','wagering_requirement'),\
                    ('player','wagering_remaining'),\
                    ('auditevent','actor_role'),\
                    ('auditevent','status')\
                )\
                SELECT r.table_name, r.column_name\
                FROM required r\
                LEFT JOIN information_schema.columns c\
                  ON c.table_schema='public'\
                 AND c.table_name = r.table_name\
                 AND c.column_name = r.column_name\
                WHERE c.column_name IS NULL\
                ORDER BY 1,2;\
              " | tee ci_artifacts/schema_guard_missing_columns.txt
            exit 1
          fi

          echo "Seeding CI admin user via /api/v1/admin/seed (ENV=ci only)"
          code="$(curl -sS -o /tmp/seed.json -w "%{http_code}" -X POST "${API_BASE}/api/v1/admin/seed")"
          echo "HTTP $code"
          cat /tmp/seed.json
          test "$code" = "200" || test "$code" = "202" || test "$code" = "204" || test "$code" = "201"


      - name: Stage CI scripts into backend container (P0)
        run: |
          set -euo pipefail

          BACKEND_ID="$(docker compose -f docker-compose.prod.yml --profile localdb ps -q backend | head -n 1)"
          test -n "$BACKEND_ID" || (echo "backend container id not found" && exit 1)
          echo "BACKEND_ID=$BACKEND_ID"

          # Copy repo-root ./scripts into the running backend container (image build context is ./backend)
          docker cp scripts "${BACKEND_ID}:/app/ci_scripts"

          # Prove files exist and python3 is available
          docker compose -f docker-compose.prod.yml --profile localdb exec -T backend sh -lc '
            ls -la /app/ci_scripts/release_smoke.py && python3 -V
          '

          # Ensure artifacts dir exists
          docker compose -f docker-compose.prod.yml --profile localdb exec -T backend sh -lc 'mkdir -p /app/artifacts/release_smoke'

      - name: Run Release Smoke Tests (P2.1) (inside backend container)
        run: |
          set -euo pipefail
          echo "Running Release Smoke Suite inside backend container..."

          docker compose -f docker-compose.prod.yml --profile localdb exec -T backend sh -lc '
            export CI_STRICT=1
            export API_BASE_URL="http://127.0.0.1:8001/api/v1"
            export BOOTSTRAP_OWNER_EMAIL="'"${BOOTSTRAP_OWNER_EMAIL}"'"
            export BOOTSTRAP_OWNER_PASSWORD="'"${BOOTSTRAP_OWNER_PASSWORD}"'"
            export ARTIFACTS_DIR=/app/artifacts/release_smoke
            python3 /app/ci_scripts/release_smoke.py
          '

          BACKEND_ID="$(docker compose -f docker-compose.prod.yml --profile localdb ps -q backend | head -n 1)"
          mkdir -p artifacts/release_smoke
          docker cp "${BACKEND_ID}:/app/artifacts/release_smoke/." artifacts/release_smoke/

          test -n "$(ls -A artifacts/release_smoke 2>/dev/null)" || (echo "No smoke artifacts found" && exit 1)

      - name: Upload Smoke Test Artifacts (P2.2)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: release-smoke-logs
          path: artifacts/release_smoke/

      - name: Check for Secret Leakage (P2.4)
        if: always()
        run: |
          echo "Checking logs for leaked secrets..."
          if grep -r "Bearer " artifacts/release_smoke/ | grep -v "***REDACTED***"; then
            echo "FAIL: Found unmasked Bearer token in logs!"
            exit 1
          fi
          if grep -r "access_token" artifacts/release_smoke/ | grep -v "***REDACTED***"; then
             echo "FAIL: Found unmasked access_token in logs!"
             # We exit 1 to fail the build if leak found, even if tests passed
             exit 1
          fi
          echo "PASS: No secrets found in logs."

      - name: Check liveness (process up)
        run: |
          set -e
          code=$(curl -s -o /dev/null -w "%{http_code}" "$API_BASE/api/health" || true)
          echo "GET /api/health => $code"
          test "$code" = "200"

      - name: Verify User Creation in DB (P0)
        run: |
          echo "Verifying admin user creation in DB..."
          sleep 5
          docker compose -f docker-compose.prod.yml --profile localdb exec -T postgres \
            psql -U postgres -d casino_db -c "select count(*) from adminuser;"
          
          docker compose -f docker-compose.prod.yml --profile localdb exec -T postgres \
            psql -U postgres -d casino_db -c "select id, email, role, status from adminuser;"
          
          # Check Tenants
          docker compose -f docker-compose.prod.yml --profile localdb exec -T postgres \
            psql -U postgres -d casino_db -c "select id, name from tenant;"

      # Login test is the ultimate truth. If this passes, we are good.
      - name: Curl login (sanity)
        run: |
          set -euo pipefail
          echo "Testing login with ${BOOTSTRAP_OWNER_EMAIL}..."
          code="$(curl -sS -o /tmp/login.json -w "%{http_code}" \
            -X POST "${API_BASE}/api/v1/auth/login" \
            -H 'content-type: application/json' \
            --data "{\"email\":\"${BOOTSTRAP_OWNER_EMAIL}\",\"password\":\"${BOOTSTRAP_OWNER_PASSWORD}\"}")"

          echo "HTTP $code"
          cat /tmp/login.json
          test "$code" = "200"

      - name: Dump localhost resolution
        if: always()
        run: |
          set +e
          mkdir -p ci_artifacts
          {
            echo "getent hosts localhost:";
            getent hosts localhost || true;
            echo;
            echo "getent ahosts localhost:";
            getent ahosts localhost || true;
          } | tee ci_artifacts/localhost_resolution.txt


      # Always collect diagnostics (success or failure) to unblock RCA.
      - name: Collect compose diagnostics (always)
        if: always()
        run: |
          set +e
          chmod +x scripts/ci_prod_compose_debug.sh
          scripts/ci_prod_compose_debug.sh docker-compose.prod.yml ci_artifacts

      - name: Dump compose state (always)
        if: always()
        run: |
          set +e
          mkdir -p ci_artifacts

          docker compose -f docker-compose.prod.yml --profile localdb ps > ci_artifacts/compose_ps.txt || true
          docker compose -f docker-compose.prod.yml --profile localdb logs --no-color --tail=300 backend > ci_artifacts/backend.log || true
          docker compose -f docker-compose.prod.yml --profile localdb logs --no-color --tail=200 postgres > ci_artifacts/postgres.log || true

          BACKEND_ID=$(docker compose -f docker-compose.prod.yml --profile localdb ps -q backend 2>/dev/null || true)
          if [ -n "$BACKEND_ID" ]; then
            docker inspect "$BACKEND_ID" > ci_artifacts/backend_inspect_full.json || true
            docker inspect "$BACKEND_ID" --format '{{json .State.Health}}' > ci_artifacts/backend_health.json || true
            if command -v jq >/dev/null 2>&1; then
              cat ci_artifacts/backend_health.json | jq . > ci_artifacts/backend_health.pretty.json || true
            fi
          fi

      - name: Upload compose artifacts (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: prod-compose-artifacts
          path: ci_artifacts/**

      - name: Setup Node (for Playwright)
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'
          cache-dependency-path: e2e/yarn.lock

      - name: Install E2E deps
        working-directory: e2e
        run: |
          yarn install --frozen-lockfile
          yarn playwright install --with-deps chromium

      - name: Wait for Frontend (admin)
        run: |
          set -e
          for i in {1..60}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:3000/login" || true)
            if [ "$code" = "200" ]; then
              echo "Frontend OK"
              exit 0
            fi
            echo "Waiting for frontend ... ($i) code=$code"
            sleep 2
          done
          echo "Frontend did not become ready in time"
          exit 1

      - name: UI smoke matrix (Playwright)
        working-directory: e2e
        env:
          E2E_BASE_URL: "http://localhost:3000"
          # UI calls go via same-origin /api proxy (avoid direct :8001 from browser)
          # Keep APIRequestContext using API_BASE if needed by tests
          E2E_API_BASE: ${{ env.API_BASE }}
          E2E_OWNER_EMAIL: ${{ env.BOOTSTRAP_OWNER_EMAIL }}
          E2E_OWNER_PASSWORD: ${{ env.BOOTSTRAP_OWNER_PASSWORD }}
        run: |
          echo "=== Environment Diagnostics ==="
          echo "Node: $(node -v)"
          echo "Yarn: $(yarn -v)"
          echo "PWD: $(pwd)"
          ls -la
          
          echo "=== Installing Browsers ==="
          npx playwright install --with-deps chromium
          
          echo "=== Running Tests ==="
          # Use '--' to pass arguments to the underlying playwright command
          yarn test:e2e -- --project=chromium

      - name: Upload Playwright artifacts
        if: failure() && hashFiles('e2e/test-results/**') != ''
        uses: actions/upload-artifact@v4
        with:
          name: playwright-artifacts
          path: |
            e2e/test-results/**

      - name: Tear down
        if: always()
        run: |
          docker compose -f docker-compose.prod.yml --profile localdb down -v --remove-orphans || true

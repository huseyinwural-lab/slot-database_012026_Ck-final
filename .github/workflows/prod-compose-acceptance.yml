name: Prod Compose Acceptance (Postgres + Migrations)

on:
  push:
    branches: [ "main", "master" ]
  pull_request:
  workflow_dispatch:

jobs:
  prod_compose_acceptance:
    if: ${{ github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository }}
    runs-on: ubuntu-latest
    timeout-minutes: 25

    env:
      # CI acceptance environment (prod/staging secret gates should NOT run here)
      ENV: ci
      SEED_ON_STARTUP: "false"
      DEBUG: "false"
      LOG_FORMAT: json
      LOG_LEVEL: INFO

      # CI için dummy secret yeterli; prod’da GitHub Secrets kullanın
      JWT_SECRET: "ci_dummy_secret_change_me"

      # NOTE: We deliberately do NOT provide payment/webhook secrets in CI acceptance.
      # Prod/staging secret gates should not run under ENV=ci.

      # Bootstrap credentials are set in a step (either from secrets or generated ephemerally)
      # to avoid CI failing when repository secrets are not configured.

      # docker-compose.prod.yml backend port mapping: 8001:8001
      # Use 127.0.0.1 (not localhost) to avoid IPv6/::1 resolution issues in CI Playwright/browser networking
      API_BASE: "http://127.0.0.1:8001"

      # docker-compose.prod.yml postgres env uses POSTGRES_PASSWORD
      POSTGRES_PASSWORD: "postgres"

      # CI db connection string (service name is 'postgres' in compose)
      DATABASE_URL: "postgresql+asyncpg://postgres:postgres@postgres:5432/casino_db"

      # Sync DSN for Alembic/psycopg2 (must match POSTGRES_PASSWORD above)
      SYNC_DATABASE_URL: "postgresql://postgres:postgres@postgres:5432/casino_db"

      # Redis is optional for this release gate (Admin+Backend only)
      REDIS_REQUIRED: "false"

      DB_POOL_SIZE: "5"
      DB_MAX_OVERFLOW: "10"

      # CORS: Explicit allowlist for CI (no wildcard) to match prod/staging rules
      # Browser origin will be http://localhost:3000
      CORS_ORIGINS: "http://localhost:3000,http://127.0.0.1:3000"


      # Frontend build args
      # Browser should talk same-origin (frontend nginx proxies /api -> backend)
      REACT_APP_BACKEND_URL: "http://localhost:3000"
      # Build metadata
      APP_VERSION: "0.0.0-ci"
      GIT_SHA: "ci"
      BUILD_TIME: "ci"

      VITE_API_URL: "http://localhost:3000/api/v1"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Show Docker versions
        run: |
          docker version
          docker compose version

      - name: Set bootstrap credentials for CI
        if: ${{ github.event_name != 'pull_request' }}
        run: |
          set -euo pipefail

          if [ -n "${{ secrets.BOOTSTRAP_OWNER_EMAIL }}" ] && [ -n "${{ secrets.BOOTSTRAP_OWNER_PASSWORD }}" ]; then
            echo "Using BOOTSTRAP_OWNER_* from GitHub Secrets"
            EMAIL="${{ secrets.BOOTSTRAP_OWNER_EMAIL }}"
            PASS="${{ secrets.BOOTSTRAP_OWNER_PASSWORD }}"
          else
            echo "BOOTSTRAP_OWNER_* secrets not set; using ephemeral CI bootstrap credentials"
            EMAIL="ci.owner@example.com"
            PASS="CI-Temp-$(date +%s)-A!"
          fi

          echo "BOOTSTRAP_ENABLED=false" >> "$GITHUB_ENV"
          echo "BOOTSTRAP_OWNER_EMAIL=$EMAIL" >> "$GITHUB_ENV"
          echo "BOOTSTRAP_OWNER_PASSWORD=$PASS" >> "$GITHUB_ENV"

          # Keep E2E credentials in sync with bootstrap
          echo "E2E_OWNER_EMAIL=$EMAIL" >> "$GITHUB_ENV"
          echo "E2E_OWNER_PASSWORD=$PASS" >> "$GITHUB_ENV"


      - name: Bring up prod stack (fresh)
        run: |
          set -e
          set -o pipefail

          mkdir -p ci_artifacts

          # Ensure backend/.env does not hard-fail compose on some runners
          if [ -f backend/.env.example ] && [ ! -f backend/.env ]; then
            cp backend/.env.example backend/.env
          fi
          if [ ! -f backend/.env ]; then
            touch backend/.env
          fi


          # Fresh DB için volume’ları sil
          docker compose -f docker-compose.prod.yml --profile localdb down -v --remove-orphans || true

          # Runner disk / build cache kaynaklı fail’leri minimize et
          docker system prune -af || true
          docker buildx prune -af || true

          # BuildKit output'u root-cause'u net gösterir (stack trace yerine gerçek fail-to-solve)
          # Ayrıca build output'u artifact'e yazıyoruz ki tek seferde RCA yapılabilsin.
          set +e
          DOCKER_BUILDKIT=1 docker compose -f docker-compose.prod.yml --profile localdb build --build-arg CI=false --pull --no-cache --progress=plain | tee ci_artifacts/compose_build.log
          build_rc=${PIPESTATUS[0]}
          set -e

          if [ "$build_rc" != "0" ]; then
            echo "=== BUILD FAILED: LAST 250 LINES (compose_build.log) ==="
            tail -n 250 ci_artifacts/compose_build.log || true
            echo "=== BUILD FAILED: GREP ROOT-CAUSE CANDIDATES ==="
            grep -E "ERROR: failed to solve:|failed to solve:|COPY failed|no space left on device|engine \"node\" is incompatible|pull access denied|manifest unknown|Cannot connect to the Docker daemon" ci_artifacts/compose_build.log | tail -n 80 || true
            exit 1
          fi

          docker compose -f docker-compose.prod.yml --profile localdb up -d --remove-orphans
          docker compose -f docker-compose.prod.yml --profile localdb ps | tee ci_artifacts/compose_ps_inline.txt
          docker compose -f docker-compose.prod.yml --profile localdb logs --no-color --tail=200 | tee ci_artifacts/compose_logs_inline_tail200.txt || true
          docker ps -a

      - name: Wait for API readiness
        run: |
          set -e
          for i in {1..60}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "$API_BASE/api/ready" || true)
            if [ "$code" = "200" ]; then
              echo "Ready OK"
              exit 0
            fi
            echo "Waiting for /api/ready ... ($i) code=$code"
            sleep 2
          done

          echo "Readiness did not become ready in time"
          echo "=== docker compose ps ==="
          docker compose -f docker-compose.prod.yml --profile localdb ps || true
          echo "=== backend logs (tail 200) ==="
          docker compose -f docker-compose.prod.yml --profile localdb logs --no-color --tail=200 backend || true
          echo "=== postgres logs (tail 200) ==="
          docker compose -f docker-compose.prod.yml --profile localdb logs --no-color --tail=200 postgres || true
          exit 1

      - name: Run Release Smoke Tests (P2.1)
        run: |
          set -euo pipefail
          echo "Running Release Smoke Suite (Strict Mode)..."
          
          # Inject CI variables explicitly
          export CI_STRICT=1
          export API_BASE_URL="$API_BASE/api/v1"
          export BOOTSTRAP_OWNER_EMAIL="${BOOTSTRAP_OWNER_EMAIL}"
          export BOOTSTRAP_OWNER_PASSWORD="${BOOTSTRAP_OWNER_PASSWORD}"
          
          # Execute runner
          python3 scripts/release_smoke.py

      - name: Upload Smoke Test Artifacts (P2.2)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: release-smoke-logs
          path: /app/artifacts/release_smoke/

      - name: Check for Secret Leakage (P2.4)
        if: always()
        run: |
          echo "Checking logs for leaked secrets..."
          if grep -r "Bearer " /app/artifacts/release_smoke/ | grep -v "***REDACTED***"; then
            echo "FAIL: Found unmasked Bearer token in logs!"
            exit 1
          fi
          if grep -r "access_token" /app/artifacts/release_smoke/ | grep -v "***REDACTED***"; then
             echo "FAIL: Found unmasked access_token in logs!"
             # We exit 1 to fail the build if leak found, even if tests passed
             exit 1
          fi
          echo "PASS: No secrets found in logs."

      - name: Check liveness (process up)
        run: |
          set -e
          code=$(curl -s -o /dev/null -w "%{http_code}" "$API_BASE/api/health" || true)
          echo "GET /api/health => $code"
          test "$code" = "200"

      - name: Verify User Creation in DB (P0)
        run: |
          echo "Verifying admin user creation in DB..."
          sleep 5
          docker compose -f docker-compose.prod.yml --profile localdb exec -T postgres \
            psql -U postgres -d casino_db -c "select count(*) from adminuser;"
          
          docker compose -f docker-compose.prod.yml --profile localdb exec -T postgres \
            psql -U postgres -d casino_db -c "select id, email, role, status from adminuser;"
          
          # Check Tenants
          docker compose -f docker-compose.prod.yml --profile localdb exec -T postgres \
            psql -U postgres -d casino_db -c "select id, name from tenant;"

      # Login test is the ultimate truth. If this passes, we are good.
      - name: Curl login (sanity)
        run: |
          set -euo pipefail
          echo "Testing login with ${BOOTSTRAP_OWNER_EMAIL}..."
          code="$(curl -sS -o /tmp/login.json -w "%{http_code}" \
            -X POST "${API_BASE}/api/v1/auth/login" \
            -H 'content-type: application/json' \
            --data "{\"email\":\"${BOOTSTRAP_OWNER_EMAIL}\",\"password\":\"${BOOTSTRAP_OWNER_PASSWORD}\"}")"

          echo "HTTP $code"
          cat /tmp/login.json
          test "$code" = "200"

      - name: Dump localhost resolution
        if: always()
        run: |
          set +e
          mkdir -p ci_artifacts
          {
            echo "getent hosts localhost:";
            getent hosts localhost || true;
            echo;
            echo "getent ahosts localhost:";
            getent ahosts localhost || true;
          } | tee ci_artifacts/localhost_resolution.txt


      # Always collect diagnostics (success or failure) to unblock RCA.
      - name: Collect compose diagnostics (always)
        if: always()
        run: |
          set +e
          chmod +x scripts/ci_prod_compose_debug.sh
          scripts/ci_prod_compose_debug.sh docker-compose.prod.yml ci_artifacts

      - name: Dump compose state (always)
        if: always()
        run: |
          set +e
          mkdir -p ci_artifacts

          docker compose -f docker-compose.prod.yml --profile localdb ps > ci_artifacts/compose_ps.txt || true
          docker compose -f docker-compose.prod.yml --profile localdb logs --no-color --tail=300 backend > ci_artifacts/backend.log || true
          docker compose -f docker-compose.prod.yml --profile localdb logs --no-color --tail=200 postgres > ci_artifacts/postgres.log || true

          BACKEND_ID=$(docker compose -f docker-compose.prod.yml --profile localdb ps -q backend 2>/dev/null || true)
          if [ -n "$BACKEND_ID" ]; then
            docker inspect "$BACKEND_ID" > ci_artifacts/backend_inspect_full.json || true
            docker inspect "$BACKEND_ID" --format '{{json .State.Health}}' > ci_artifacts/backend_health.json || true
            if command -v jq >/dev/null 2>&1; then
              cat ci_artifacts/backend_health.json | jq . > ci_artifacts/backend_health.pretty.json || true
            fi
          fi

      - name: Upload compose artifacts (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: prod-compose-artifacts
          path: ci_artifacts/**

      - name: Setup Node (for Playwright)
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'
          cache-dependency-path: e2e/yarn.lock

      - name: Install E2E deps
        working-directory: e2e
        run: |
          yarn install --frozen-lockfile
          yarn playwright install --with-deps chromium

      - name: Wait for Frontend (admin)
        run: |
          set -e
          for i in {1..60}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:3000/login" || true)
            if [ "$code" = "200" ]; then
              echo "Frontend OK"
              exit 0
            fi
            echo "Waiting for frontend ... ($i) code=$code"
            sleep 2
          done
          echo "Frontend did not become ready in time"
          exit 1

      - name: UI smoke matrix (Playwright)
        working-directory: e2e
        env:
          E2E_BASE_URL: "http://localhost:3000"
          # UI calls go via same-origin /api proxy (avoid direct :8001 from browser)
          # Keep APIRequestContext using API_BASE if needed by tests
          E2E_API_BASE: ${{ env.API_BASE }}
          E2E_OWNER_EMAIL: ${{ env.BOOTSTRAP_OWNER_EMAIL }}
          E2E_OWNER_PASSWORD: ${{ env.BOOTSTRAP_OWNER_PASSWORD }}
        run: |
          echo "=== Environment Diagnostics ==="
          echo "Node: $(node -v)"
          echo "Yarn: $(yarn -v)"
          echo "PWD: $(pwd)"
          ls -la
          
          echo "=== Installing Browsers ==="
          npx playwright install --with-deps chromium
          
          echo "=== Running Tests ==="
          # Use '--' to pass arguments to the underlying playwright command
          yarn test:e2e -- --project=chromium

      - name: Upload Playwright artifacts
        if: failure() && hashFiles('e2e/test-results/**') != ''
        uses: actions/upload-artifact@v4
        with:
          name: playwright-artifacts
          path: |
            e2e/test-results/**

      - name: Tear down
        if: always()
        run: |
          docker compose -f docker-compose.prod.yml --profile localdb down -v --remove-orphans || true

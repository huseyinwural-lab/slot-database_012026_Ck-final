name: Prod Compose Acceptance (Postgres + Migrations)

on:
  push:
    branches: [ "main", "master" ]
  pull_request:
  workflow_dispatch:

jobs:
  prod_compose_acceptance:
    runs-on: ubuntu-latest
    timeout-minutes: 25

    env:
      # Uygulamanın prod/staging davranışını tetiklemek için
      ENV: staging
      SEED_ON_STARTUP: "false"
      DEBUG: "false"
      LOG_FORMAT: json
      LOG_LEVEL: INFO

      # CI için dummy secret yeterli; prod’da GitHub Secrets kullanın
      JWT_SECRET: "ci_dummy_secret_change_me"

      # Bootstrap guard'ı geçtiğimiz için CI'da bootstrap'ı açıyoruz
      BOOTSTRAP_ENABLED: "true"

      # Owner credentials: repo secrets'ten gelecek (Settings > Secrets and variables > Actions)
      BOOTSTRAP_OWNER_EMAIL: ${{ secrets.BOOTSTRAP_OWNER_EMAIL }}
      BOOTSTRAP_OWNER_PASSWORD: ${{ secrets.BOOTSTRAP_OWNER_PASSWORD }}

      # (Opsiyonel) E2E/Playwright tarafı farklı env isimleri bekliyorsa aynı değeri map et
      E2E_OWNER_EMAIL: ${{ secrets.BOOTSTRAP_OWNER_EMAIL }}
      E2E_OWNER_PASSWORD: ${{ secrets.BOOTSTRAP_OWNER_PASSWORD }}

      # docker-compose.prod.yml backend port mapping: 8001:8001
      API_BASE: "http://localhost:8001"

      # docker-compose.prod.yml postgres env uses POSTGRES_PASSWORD
      POSTGRES_PASSWORD: "postgres"

      # CI db connection string (service name is 'postgres' in compose)
      DATABASE_URL: "postgresql+asyncpg://postgres:postgres@postgres:5432/casino_db"

      DB_POOL_SIZE: "5"
      DB_MAX_OVERFLOW: "10"

      # CORS: Allow all for CI to prevent any origin/network issues
      CORS_ORIGINS: "*"


      # Frontend build args
      REACT_APP_BACKEND_URL: "http://localhost:8001"
      VITE_API_URL: "http://localhost:8001/api/v1"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Show Docker versions
        run: |
          docker version
          docker compose version

      - name: Bring up prod stack (fresh)
        env:
          BOOTSTRAP_ENABLED: "true"
          BOOTSTRAP_OWNER_EMAIL: ${{ secrets.BOOTSTRAP_OWNER_EMAIL }}
          BOOTSTRAP_OWNER_PASSWORD: ${{ secrets.BOOTSTRAP_OWNER_PASSWORD }}
        run: |
          set -e
          set -o pipefail

          mkdir -p ci_artifacts

          # Fresh DB için volume’ları sil
          docker compose -f docker-compose.prod.yml down -v --remove-orphans || true

          # Runner disk / build cache kaynaklı fail’leri minimize et
          docker system prune -af || true
          docker buildx prune -af || true

          # BuildKit output'u root-cause'u net gösterir (stack trace yerine gerçek fail-to-solve)
          # Ayrıca build output'u artifact'e yazıyoruz ki tek seferde RCA yapılabilsin.
          set +e
          DOCKER_BUILDKIT=1 docker compose -f docker-compose.prod.yml build --pull --no-cache --progress=plain | tee ci_artifacts/compose_build.log
          build_rc=${PIPESTATUS[0]}
          set -e

          if [ "$build_rc" != "0" ]; then
            echo "=== BUILD FAILED: LAST 250 LINES (compose_build.log) ==="
            tail -n 250 ci_artifacts/compose_build.log || true
            echo "=== BUILD FAILED: GREP ROOT-CAUSE CANDIDATES ==="
            grep -E "ERROR: failed to solve:|failed to solve:|COPY failed|no space left on device|engine \"node\" is incompatible|pull access denied|manifest unknown|Cannot connect to the Docker daemon" ci_artifacts/compose_build.log | tail -n 80 || true
            exit 1
          fi

          docker compose -f docker-compose.prod.yml up -d --remove-orphans
          docker compose -f docker-compose.prod.yml ps | tee ci_artifacts/compose_ps_inline.txt
          docker compose -f docker-compose.prod.yml logs --no-color --tail=200 | tee ci_artifacts/compose_logs_inline_tail200.txt || true
          docker ps -a

      - name: Wait for API health
        run: |
          set -e
          for i in {1..60}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "$API_BASE/api/health" || true)
            if [ "$code" = "200" ]; then
              echo "Health OK"
              exit 0
            fi
            echo "Waiting for /api/health ... ($i) code=$code"
            sleep 2
          done
          echo "Health did not become ready in time"
          exit 1

      - name: Check readiness (DB up)
        run: |
          set -e
          code=$(curl -s -o /dev/null -w "%{http_code}" "$API_BASE/api/ready" || true)
          echo "GET /api/ready => $code"
          test "$code" = "200"

      - name: Verify User Creation in DB (P0)
        run: |
          echo "Verifying admin user creation in DB..."
          sleep 5
          docker compose -f docker-compose.prod.yml exec -T postgres \
            psql -U postgres -d casino_db -c "select count(*) from adminuser;"
          
          docker compose -f docker-compose.prod.yml exec -T postgres \
            psql -U postgres -d casino_db -c "select id, email, role, status from adminuser;"
          
          # Check Tenants
          docker compose -f docker-compose.prod.yml exec -T postgres \
            psql -U postgres -d casino_db -c "select id, name from tenant;"

      # Login test is the ultimate truth. If this passes, we are good.
      - name: Test login via curl
        env:
          EMAIL: ${{ secrets.BOOTSTRAP_OWNER_EMAIL }}
          PASSWORD: ${{ secrets.BOOTSTRAP_OWNER_PASSWORD }}
        run: |
          echo "Testing login with ${EMAIL}..."
          curl -sS -X POST "http://localhost:8001/api/v1/auth/login" \
            -H "Content-Type: application/json" \
            -d "{\"email\":\"${EMAIL}\",\"password\":\"${PASSWORD}\"}" | tee /tmp/login.json

          if grep -q "access_token" /tmp/login.json; then
            echo "Login Verified via Curl!"
          else
            echo "Login Failed via Curl!"
            cat /tmp/login.json
            exit 1
          fi

      # Always collect diagnostics (success or failure) to unblock RCA.
      - name: Collect compose diagnostics (always)
        if: always()
        run: |
          set +e
          chmod +x scripts/ci_prod_compose_debug.sh
          scripts/ci_prod_compose_debug.sh docker-compose.prod.yml ci_artifacts

      - name: Dump compose state (always)
        if: always()
        run: |
          set +e
          mkdir -p ci_artifacts

          docker compose -f docker-compose.prod.yml ps > ci_artifacts/compose_ps.txt || true
          docker compose -f docker-compose.prod.yml logs --no-color --tail=300 backend > ci_artifacts/backend.log || true
          docker compose -f docker-compose.prod.yml logs --no-color --tail=200 postgres > ci_artifacts/postgres.log || true

          BACKEND_ID=$(docker compose -f docker-compose.prod.yml ps -q backend 2>/dev/null || true)
          if [ -n "$BACKEND_ID" ]; then
            docker inspect "$BACKEND_ID" --format '{{json .State.Health}}' > ci_artifacts/backend_health.json || true
            if command -v jq >/dev/null 2>&1; then
              cat ci_artifacts/backend_health.json | jq . > ci_artifacts/backend_health.pretty.json || true
            fi
          fi

      - name: Upload compose artifacts (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: prod-compose-artifacts
          path: |
            ci_artifacts/compose_ps.txt
            ci_artifacts/compose_logs_tail.txt
            ci_artifacts/inspect_*.json
            ci_artifacts/compose_build.log
            ci_artifacts/compose_ps_inline.txt
            ci_artifacts/compose_logs_inline_tail200.txt

      - name: Setup Node (for Playwright)
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'
          cache-dependency-path: e2e/yarn.lock

      - name: Install E2E deps
        working-directory: e2e
        run: |
          yarn install --frozen-lockfile || yarn install
          yarn playwright install --with-deps chromium

      - name: Wait for Frontend (admin)
        run: |
          set -e
          for i in {1..60}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:3000/login" || true)
            if [ "$code" = "200" ]; then
              echo "Frontend OK"
              exit 0
            fi
            echo "Waiting for frontend ... ($i) code=$code"
            sleep 2
          done
          echo "Frontend did not become ready in time"
          exit 1

      - name: UI smoke matrix (Playwright)
        working-directory: e2e
        env:
          E2E_BASE_URL: "http://localhost:3000"
          E2E_API_BASE: "http://localhost:8001"
          E2E_OWNER_EMAIL: ${{ env.BOOTSTRAP_OWNER_EMAIL }}
          E2E_OWNER_PASSWORD: ${{ env.BOOTSTRAP_OWNER_PASSWORD }}
        run: |
          echo "=== Environment Diagnostics ==="
          echo "Node: $(node -v)"
          echo "Yarn: $(yarn -v)"
          echo "PWD: $(pwd)"
          ls -la
          
          echo "=== Installing Browsers ==="
          npx playwright install --with-deps chromium
          
          echo "=== Running Tests ==="
          # Use '--' to pass arguments to the underlying playwright command
          yarn test:e2e -- --project=chromium

      - name: Upload Playwright artifacts
        if: failure() && hashFiles('e2e/test-results/**') != ''
        uses: actions/upload-artifact@v4
        with:
          name: playwright-artifacts
          path: |
            e2e/test-results/**

      - name: Tear down
        if: always()
        run: |
          docker compose -f docker-compose.prod.yml down -v --remove-orphans || true
